{"pages":[],"posts":[{"title":"hexo博客构建","text":"搭建博客花了我不少时间，由于各种原因，踩了很多坑，最终才将博客搭建起来，废话不多说。该文章是自搭建好博客后的第一篇博客，文章将整理博客管理、github上传项目等操作命令，便于以后查阅。注：该博客采用Github+hexo搭建而成 一、hexo管理博客新建一篇博客1$ hexo new [文件名] 生成静态页面1$ hexo generate 使用该命令会在博客根目录下生成public文件（该文件即上传到github上的文件） 清除缓存1$ hexo clear 使用该命令会在博客根目录下删除public文件 运行本地服务1$ hexo server 使用该命令会在本地生成一个预览页面，浏览器输入localhost:4000，需要注意的是开启该服务后会占用4000端口，所以如果4000端口已经被占用的话会打不开页面，可使用命令 1$ hexo server -p 5000 该命令可将端口4000换成端口5000 部署页面1$ hexo deploy 使用该命令前根目录下_config.yml配置文件需将github地址等配置好,也可直接使用命令 1$ hexo d -g 直接部署前生成静态页面 二、github代码上传(最好在git bash中运行)git初始化1$ git init 添加文件1$ git add * 此处*代表将该目录下所有文件上传，若要将某文件上传，则可换为该文件名 commit到仓库1$ git commit -m &quot;注释语句&quot; 注释语句可换成任意，例：第一次上传 本地仓库关联到github1$ git remote add origin https://github.com/Qxiaoqi/HTML-task.git 此处地址为github代码仓库的地址，复制到上处即可。其中可能报错如下 1fatal: remote origin already exists. 则可使用 1$ git remote rm origin 删除原来的代码仓库地址 上传代码1$ git push -u origin master 中间可能会输入账号密码","link":"/hexo%E5%8D%9A%E5%AE%A2%E6%9E%84%E5%BB%BA/"},{"title":"Express+MySQL实现登陆界面","text":"最近连着整理了好几篇博客，这些都是前一段时间做的东西，希望拿出来整理一下，加深印象。 之前看了一些nodejs，然后希望做出来点东西来实践，然后刚好在掘金上看到一个很棒的登陆效果，于是把他复现的同时也顺手做了个和后端交互的部分，就是注册账号，和登陆账号这么个简单的功能。然后发现express框架真的很好用，nodejs这块就采用了express框架来写，数据库用了Mysql。 页面展示感觉还是有点小炫酷的，登陆页面是一个动态效果，一个方块气泡上升的效果。 登陆界面 注册界面 技术细节前端效果部分气泡效果主要就是一层一层的往上压，使用z-index来控制谁在上面，该效果则是气泡在背景上面。 123456789101112&lt;ul class=&quot;bg-bubbles&quot;&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; css代码选取部分，其他的可以自己定义 123456789101112131415161718192021222324252627282930313233ul li { position: absolute; z-index: 5; list-style: none; position: absolute; bottom: -160px; width: 40px; height: 40px; background-color: rgba(255, 255, 255, 0.15); animation: square 25s infinite; //依次为动画名称，时间，播放次数（无限） transition-timing-function: linear; //速度曲线（从头到尾相同） &amp;:nth-child(1) { left: 10%; } &amp;:nth-child(2) { left: 20%; width: 90px; height: 90px; animation-delay: 2s; animation-duration: 17s; } //以上自己定义 //动画执行 @keyframes square { 0% { transform: translateY(-700px); } 100% { transform: translateY(-700px) rotate(600deg); } } 上面代码使用less写的，less语法很简单，相比于sass应该来说语法少了很多，可以使用Sublime Text的插件来实现自动编译成css的效果，或者也可以使用webpack，gulp等自动胡工具通过编写任务来实现编译。 背景使用background-image: linear-gradient( 135deg, #FFF6B7 10%, #F6416C 100%);来分别控制颜色渐变方向，两个颜色 气泡的上升是通过translateY()来控制的 气泡的旋转是通过rotate()来控制的 但是有一处不知道为什么，气泡为什么会在最上面疑似停留一会才消失的效果，倘若是因为transition-timing-function: 控制速度曲线的原因的话，那么此处设置的是linear应该是一直平均速度运行，为什么在最后会很慢呢。暂未解决 弹窗效果原理很简单，当用户点击注册新账号的时候会调用一个函数，改函数会将一个之前写好的并用display:none隐藏的div块重新改为display:block使之重新显现。同时也可以在之前写好一个大的div并用z-index控制层叠位置来使整个背景遮罩变暗 123456789101112131415161718192021//背景遮罩&lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;//注册窗口&lt;div class=&quot;register-box&quot;&gt; &lt;div class=&quot;close-box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;register-content&quot;&gt; &lt;div class=&quot;register-username&quot;&gt; &lt;input type=&quot;text&quot; placeholder=&quot;请输入用户名&quot; id=&quot;register-username&quot;&gt; &lt;/div&gt; &lt;div class=&quot;register-password&quot;&gt; &lt;input type=&quot;password&quot; placeholder=&quot;请输入密码&quot; id=&quot;register-password&quot;&gt; &lt;/div&gt; &lt;div class=&quot;register-repassword&quot;&gt; &lt;input type=&quot;password&quot; placeholder=&quot;请再次输入密码&quot; id=&quot;register-repassword&quot;&gt; &lt;/div&gt; &lt;div class=&quot;register-button&quot;&gt; &lt;button&gt;立即注册&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 12345678910var showRegister = function() { console.log(&quot;s&quot;); $(&quot;.overlay&quot;).css(&quot;display&quot;,&quot;block&quot;); $(&quot;.register-box&quot;).css(&quot;display&quot;,&quot;block&quot;);}var closeRegister = function() { $(&quot;.overlay&quot;).css(&quot;display&quot;,&quot;none&quot;); $(&quot;.register-box&quot;).css(&quot;display&quot;,&quot;none&quot;);} express框架部分服务器运行首先，这一部分要想跑起来的代码 12345678var server = app.listen(8888, function () { var host = server.address().address var port = server.address().port console.log(&quot;应用实例，访问地址为 http://%s:%s&quot;, host, port) }) 端口号为8888，同时输出对应访问地址 设置路由然后设置相应路由，即访问不同地址的时候返回给前端的内容不同 1234567891011121314151617181920212223app.get('/', function (req, res) { res.sendFile(__dirname + &quot;/public/&quot; + &quot;index.html&quot;);})app.post('/process_login',function (req, res) { console.log(req.body.username); console.log(req.body.password); if(req.body.username === &quot;xiaoqi&quot; &amp;&amp; req.body.password === &quot;1111&quot;) { res.end(JSON.stringify(dataSuccess)); } else { res.end(JSON.stringify(dataError)); } })//调用与数据库交互的方法app.post('/process_register',function (req, res) { console.log(req.body.username); console.log(req.body.password); userDao.add(req, res); }) sendFile方法返回一个文件 get方法时要返回数据给前端需要使用req.query来获取URL的查询参数串 post方法使用req.body获得请求主体 然后返回给前端的要是JSON格式转成字符串的格式 此处还未使用mysql，所以假定了一个账号和密码方便此时的测试 设置静态文件当完成上述部分之后会发现相应的css与js内容并未配置到相应html文件中，在express提供了内置的中间件express.static来设置静态文件，例如将相应的文件都放在public目录下。 1app.use(express.static('public')); 使用一行简单的命令即可 json解析当运行的时候会发现使用ajax提交的数据无法被解析，那么可以使用express中的一个bodyParser中间件来进行解析，简单的两行代码 123// 添加json解析app.use(bodyParser.json());app.use(bodyParser.urlencoded({extended: false})); 使用之前要引入var bodyParser = require('body-parser'); 登陆逻辑这部分比较的没什么新的要整理的，主要就是ajax传值的时候记得用JSON.stringify把json格式转成字符串。 mysql数据库部分数据库部分为了使项目看起来更有层次，多添加了两个文件夹，conf用来放配置文件，dao用来放与数据库交互的部分 创建mysql表12345678910111213141516171819202122SET NAMES utf8;SET FOREIGN_KEY_CHECKS = 0;-- ------------------------------ Table structure for `websites`-- ----------------------------DROP TABLE IF EXISTS `users`;CREATE TABLE `users` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(255) NOT NULL DEFAULT '' COMMENT '用户名', `password` varchar(255) NOT NULL DEFAULT '', PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;-- ------------------------------ Records of `websites`-- ----------------------------BEGIN;INSERT INTO `users` VALUES ('1', 'xiaoqi', '1111');COMMIT;SET FOREIGN_KEY_CHECKS = 1; 只有三个值，分别是id，username和password非常的简单 conf中数据库配置文件123456789101112// conf/db,js// MySQL数据库连接配置module.exports = { mysql: { host: 'localhost', user: 'root', password: '1111', port: '3306', database: 'login_information' }}; dao中数据库命令编写123456789var user = { insert: 'INSERT INTO users(id, username, password) VALUE(0,?,?)', update: 'update users set username=?, password=? where id=?', delete: 'delete form users where id=?', queryById: 'select * from users where id=?', queryAll: 'select * from users'};module.exports = user; dao中与数据库交互1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//dao/userDao.js//实现与Mysql交互var mysql = require('mysql');var $conf = require('../conf/db');var $sql = require('./userSql');// var connection = mysql.createConnection($conf.mysql);var pool = mysql.createPool( $conf.mysql );//向前端返回结果var jsonWrite = function(res, ret) { if(typeof ret === 'undefined') { console.log(&quot;ret === undefined&quot;); console.log(&quot;ret =&quot; + ret); res.end(JSON.stringify({ status: '2', msg: '操作失败' })); } else { console.log(&quot;ret !== undefined&quot;); console.log(ret); res.end(JSON.stringify(ret)); }};module.exports = { add: function(req, res) { console.log(&quot;add方法运行&quot;); pool.getConnection(function(err, connection) { if(err) { // console.log(&quot;pool报错&quot;); throw err; } var param = req.body; connection.query($sql.insert, [param.username, param.password], function(err, result) { if(result) { result = { status: 200, msg: '增加成功' }; } //以json形式，把操作结果返回给前端 jsonWrite(res, result); // 释放连接 connection.release(); }) }) }} 数据库这部分代码整合了网上的代码，并加上了我自己的内容，但是对于其中数据库部分的一些原理可能不是很了解，比如说pool连接池 query方法就类似于直接在命令行中敲sql命令 可以在数据库中查询，每当注册新用户之后，确实发现数据库中新增了相应的数据，那么这个项目的核心已经基本完成了。 后记整理这篇文章的时候大概已经是做完这个项目一周之后的事情了，法相其中的一些小细节已经忘了，只能整理一些大概的内容，感觉效果并不是非常的好，所以以后在做完项目的时候一定要第一时间整理，才能达到最好的效果。","link":"/express-mysql%E5%AE%9E%E7%8E%B0%E7%99%BB%E9%99%86%E7%95%8C%E9%9D%A2/"},{"title":"如何实现一个轮播图","text":"做项目的时候刚好要做轮播图，之前在微信小程序上做过，但是那个非常的简单，因为很多功能已经封装在了API里面，所以只需要指定几张图片就能达成效果。现在将使用JQuery来实现轮播图效果。 轮播图技术实现轮播图效果 轮播图下方有每个图的按钮，鼠标放在上面即会跳转到相应页面，而且当鼠标停留在图片上的时候，轮播图将会暂停，以便当用户被某个图片吸引时不至于跳到另一张图片。 原理轮播图就是将所有的图片使用float来将所有的图片都放成一行上，然后通过js控制图片的移动，原理图如下: 然后还有一处要注意的地方，就是当移动到最后一张图的时候，为了让其依然向左拉动，必须在最后加上复制的第一张图，使之连贯，动画结束后重新定位到起点，然后将最后一张删去 代码部分html代码12345678910111213141516171819&lt;div class=&quot;banner-wrapper&quot;&gt; &lt;!-- banner图像 --&gt; &lt;div class=&quot;banner-focus&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;div class=&quot;banner-img banner-img0&quot;&gt;&lt;/div&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;div class=&quot;banner-img banner-img1&quot;&gt;&lt;/div&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;div class=&quot;banner-img banner-img2&quot;&gt;&lt;/div&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;div class=&quot;banner-img banner-img3&quot;&gt;&lt;/div&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;!-- banner切换按钮 --&gt; &lt;div class=&quot;banner-btn&quot;&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 这里图片并没有采用img标签，而是选择了div标签，然后使用background属性的url指定图片地址，这种方法的好处是不用指定图片的大小，通过设置background-size可以让图片达到充满目标而且多余的部分不显示。因此以后尽量不要使用img标签。应该根据实际情况选择，当图片不是内容的一部分时使用background less代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980.banner-wrapper { /*轮播图*/ padding-top: 80px; height: 550px; // background-color: #DB6A6A; position: relative; .banner-focus { height: 550px; width: 100%; // background-color: #351818; overflow: hidden; position: relative; ul { position: absolute; width: 100%; li { float: left; width: 100%; height: 550px; list-style: none; .banner-img { width: 100%; height: 550px; } .banner-img0 { /*后面改路径*/ background: url(&quot;./test/images/0.jpg&quot;) no-repeat center; background-size: 100%; } .banner-img1 { /*后面改路径*/ background: url(&quot;./test/images/1.jpg&quot;) no-repeat center; background-size: 100%; } .banner-img2 { /*后面改路径*/ background: url(&quot;./test/images/2.jpg&quot;) no-repeat center; background-size: 100%; } .banner-img3 { /*后面改路径*/ background: url(&quot;./test/images/3.jpg&quot;) no-repeat center; background-size: 100%; } } } } .banner-btn { position: absolute; bottom: 30px; left: 50%; margin-left: -52px; span { // position: absolute; float: left; width: 6px; height: 6px; background-color: #E0DFE0; border-radius: 50%; margin-right: 20px; cursor: pointer; &amp;:hover { background-color: #595959; } } }} css部分需要注意的是 最外层banner-wrapper用position:relative来给内层banner-focus的position:absolute定位 banner-focus需要使用overflow:relative来将多余的部分隐藏 若想将内层元素用width百分比来表示，必须指定其父元素宽度才能成功 设置background来让其自动填充，省去了切图的麻烦 js代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//============================轮播图部分函数=====================/*轮播图主函数*/var bannerRolling = function() { var sWidth = $(&quot;.banner-focus&quot;).width(); //获取焦点图的宽度（显示面积） var len = $(&quot;.banner-focus ul li&quot;).length; //获取焦点图个数 var index = 0; var picTimer; console.log(sWidth); console.log(len); //为小按钮添加鼠标滑入事件，以显示相应的内容 $(&quot;.banner-btn span&quot;).mouseenter(function() { index = $(&quot;.banner-btn span&quot;).index(this); showPics(index, sWidth); console.log(index, sWidth); // console.log(&quot;按钮滑入&quot;); }); /* 本例为左右滚动，即所有li元素都是在同一排向左浮动， 所以这里需要计算出外围ul元素的宽度 */ $(&quot;.banner-focus ul&quot;).css(&quot;width&quot;,sWidth * (len+1)); /* 因为图片未设置固定宽度，所以之前设置的100%会随着父元素变宽而撑大， 所以此处应该相应设置为父元素的1/(len+1) */ $(&quot;.banner-focus ul li&quot;).css(&quot;width&quot;,sWidth * (len+1) / 5); /*直接自动播放*/ picTimer = setInterval(function() { if(index === len) { //如果索引值等于li元素个数，说明最后一张图播放完毕，接下来要显示第一张图，即调用showFirPic()，然后将索引值清零 index = 0; showFirstPic(len, sWidth); } else { //如果索引值不等于li元素个数，按普通状态切换，调用showPics() showPics(index, sWidth); } index++; },4000); //此2000代表自动播放的间隔，单位：毫秒 //鼠标滑上焦点图时停止自动播放，滑出时开始自动播放 $(&quot;.banner-focus&quot;).hover(function() { clearInterval(picTimer); },function() { picTimer = setInterval(function() { if(index === len) { //如果索引值等于li元素个数，说明最后一张图播放完毕，接下来要显示第一张图，即调用showFirPic()，然后将索引值清零 index = 0; showFirstPic(len, sWidth); } else { //如果索引值不等于li元素个数，按普通状态切换，调用showPics() showPics(index, sWidth); } index++; },4000); //此2000代表自动播放的间隔，单位：毫秒 }); }//显示图片函数，根据接收的index值显示相应的内容 function showPics(index, sWidth) { //普通切换 var nowLeft = - (index * sWidth); //根据index值计算ul元素的left值 $(&quot;.banner-focus ul&quot;).stop(true,false).animate({&quot;left&quot;:nowLeft},500); //通过animate()调整ul元素滚动到计算出的position // $(&quot;#focus div.btn span&quot;).animate({&quot;opacity&quot;:&quot;0.4&quot;},300).eq(index).animate({&quot;opacity&quot;:&quot;1&quot;},100); //为当前的按钮切换到选中的效果 } //最后一张图自动切换到第一张图时专用 function showFirstPic(len, sWidth) { $(&quot;.banner-focus ul&quot;).append($(&quot;.banner-focus ul li:first&quot;).clone());//为了达到从最右边到最左边还是往左移动效果，而不是往右移动 var nowLeft = - (len * sWidth); //通过li元素个数计算ul元素的left值，也就是最后一个li元素的右边 $(&quot;.banner-focus ul&quot;).stop(true,false).animate({&quot;left&quot;:nowLeft},500,function() { //通过callback，在动画结束后把ul元素重新定位到起点，然后删除最后一个复制过去的元素 $(&quot;.banner-focus ul&quot;).css(&quot;left&quot;,&quot;0&quot;); $(&quot;.banner-focus ul li:last&quot;).remove(); }); // $(&quot;#focus div.btn span&quot;).animate({&quot;opacity&quot;:&quot;0.4&quot;},300).eq(index).animate({&quot;opacity&quot;:&quot;1&quot;},100); //为当前的按钮切换到选中的效果 } setInterval()函数用来不断调用内容，为了让一开始轮播图自动滚动，要直接用setInterval函数然后实现鼠标聚焦内容的时候停止滚动，使之hover用clearInterval使其停止，然后用callback回调函数继续滚动 滚动原理是通过position:absolute然后使用left来指定展示哪一张图片 由于我并没有指定图像大小，所以我在此处设置了图像宽度为width:100%来自动调整，那么此时li的父元素ul会是所有图片宽度之和，根据width:100%会参照其父元素的原因，我在此处指定了li的宽度，为ul宽度的1/(len+1),len+1是因为会复制一张图片 后记还有一种轮播图是用纯CSS效果写的，目前还没有细读代码，纯css的局限性是似乎不能指定显示哪一张图片，而是让其自动滚动。","link":"/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%BD%AE%E6%92%AD%E5%9B%BE/"},{"title":"background属性和img标签","text":"background这个属性可以说是很常见了，基本上是使用的非常频繁的一个属性，但是真说起来background属性，我又不能说是十分的清楚。本来说准备整理一下background属性，但是在整理的时候又发现了许多不清楚的地方，比如说和img区别？那么先把问题一个一个罗列下来，逐个解决。 在此，我要更正一个错误。那就是，原来我认为能用background-image解决的就不用img标签(似乎img用不到了？)，但是详细了解之后认为这是不正确的，区别将在问题一进行介绍。 问题1.background-image和img的区别？ 2.background-size各个属性功能？ 3.什么时候使用background什么时候使用img？ 4.使用background-image的时候可以使其自适应屏幕宽度（比如说做轮播图的时候，可以指定宽度为width:100%，然后再指定一个height，使用background-size来让其充满），但是若使用img的话如何来达到这种效果。在我的印象中，img若指定width:100%的话height也会相应的变化，意思就是成比例变化，如果说同时指定width和height的话，若比例不对，图像会变形（拉伸、压缩之类的）。那么这种情况下，如何适应用户的不同屏幕？这个问题也是整理这篇文章的最大原因。 解答问题一：background-image和img的区别 &amp;&amp; 问题三：什么时候使用background什么时候使用img？边整理区别的时候，再stack Overflow上看到了一个整理的很好的答案，感觉开启了新世界的大门。在此，我要推荐一下stack Overflow这个网站，除了全是英语阅读比较困难外，基本上很多问题都能在上面找到。果然对程序员来说stack Overflow和github两个网站就能解决大部分问题。比搜索引擎查的答案更加的全面，在此引用一下答案 上面的答案可以说是很全面了，那么大概翻译一下，提取几个要点，如下 使用img的情况 当你想让打印页面时，你想让图片被默认包含在你的页面上，请使用img标签 当图像带有重要语义的时候，比如警告图标，请使用img标签（带有alt文本）因为这样的话即时因为一些问题而使图片没有加载出来，但是由于有alt属性，可以让文本代替图片，以至于重要信息不会因为图片无法加载而丢失。想象一下，如果使用background-image的话，倘若没法加载图片将会怎么样，也许就会错过一些重要的信息 如果图像是内容的一部分，最好使用img+alt 如果你想让图像成比例放大或缩小，请使用img标签。background-image只能制定宽和高，虽然可以指定background-size，但依然不是成比例的，必然有一部分内容会缺失。 使用img而不是背景图像可以显著提高动画在后台的性能【这句话暂时并未理解】 当你想你的图片能被搜索引擎搜索到时，或者说更便于做SEO【答案来自其他人】 使用backgroung-image的情况 如果图像不是内容的一部分，请使用CSS背景图像 使用CSS背景图像做图像替换的文本 如果你需要提高下载时间，就像CSS sprites 【css sprites的一个特性是似乎能让所有图片合成一张加载，这样能改善下载时间，为什么呢，学过数字图像处理可以知道，每个图像的颜色表都不一样，每一张图都需要一个颜色表的话自然不如只有一个颜色表占用空间少。具体css sprites内容还不太清楚】 使用backgroung-size，以拉伸背景图像填充整个窗口。 总结那么整理一下可以知道了，当使用不包含内容的图像，比如说背景的时候，那么完全可以使用background-image来让工作变得更加简单。但是倘若包含重要内容，应该使用img来作为一个HTML标签存在其中。 问题二：background-size各个属性功能？引自MDN background 是CSS简写属性，用来集中设置各种背景属性。background 可以用来设置一个或多个属性:background-color, background-image, background-position, background-repeat, background-size, background-attachment。 background初始值： background-image: none background-position: 0% 0% background-size: auto auto background-repeat: repeat background-origin: padding-box background-clip: border-box background-attachment: scroll background-color: transparent background-color用于设置背景色 background-image用于引入图片 background-position规定背景图像位置 background-repeat规定是否平铺 background-size规定图像尺寸 background-attachment设置背景图像是否固定或者随着页面的其余部分滚动 background-position测试图700px,700px 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;background-position&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .test { width: 600px; height: 600px; background-image: url(&quot;demo.jpg&quot;); //background-position: 0% center; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;test&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 将position注释的时候，可以看到处于默认状态0% 0%的状态，那么注释之后原图变成了 可以看到左边框的黑线仍能显示，而上边框的黑线已经没有了，那么得出结论，第一个值可以理解成左右位置，而第二个则可以理解成上下位置，center则代表上下居中。其他同理。 background-repeat当图片宽或者高小于css指定的宽或者高时，空白的部分将被平铺，如图 12345678.test { width: 730px; height: 730px; background-image: url(&quot;demo.jpg&quot;); background-color: #000000; /*background-position: 0% center;*/ background-repeat: repeat; } 当设置成no-repeat时，可以看到有黑色背景透出，则可看出效果。 1background-repeat: no-repeat; background-size做一个测试，来说明具体工作情况 123456.test { width: 400px; height: 300px; background-image: url(&quot;demo.jpg&quot;); background-color: #000000; } 可以看到不设置background-size时显示不全 1.当都设置成100%时 12345678.test { width: 400px; height: 300px; background-image: url(&quot;demo.jpg&quot;); background-color: #000000; background-repeat: no-repeat; background-size: 100% 100%; } 可以看到长和宽都被拉伸到了最大限度 2.当第一个设置成100%时 1background-size: 100% auto; 可以看到宽被拉到100% 3.当第二个设置成100%时 1background-size: auto 100%; 可以看到高被拉到了100% 4.设置成cover 把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。背景图像的某些部分也许无法显示在背景定位区域中。 123456789.test { width: 400px; height: 300px; background-image: url(&quot;demo.jpg&quot;); background-color: #000000; /*background-position: 0% center;*/ background-repeat: no-repeat; background-size: cover; } 改变width和height 123456789.test { width: 300px; height: 400px; background-image: url(&quot;demo.jpg&quot;); background-color: #000000; /*background-position: 0% center;*/ background-repeat: no-repeat; background-size: cover; } 可以看到结果不一样，即解释了什么叫做使背景完全覆盖背景区域,就是说将宽或者高大的哪一个拉到最大 5.设置成contain 把图像图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域。 测试方法同上，第一个设置width:400px;height:300px第二个设置width:300px;height:400px，结果如下，第一个 第二个 则可以充分看出确实是高或者宽完全适应背景区域 background-attachment scroll 默认值。背景图像会随着页面其余部分的滚动而移动。fixed 当页面的其余部分滚动时，背景图像不会移动。inherit 规定应该从父元素继承 background-attachment 属性的设置。 默认是会滚动的，当设置成fixed的时候，背景就会固定不动，可以借此做出比较炫酷的效果。 问题四：关于轮播图关于这个问题，我想了想，倘若使用img标签的话（通过上面整理img应该更适合做轮播图，因为它在页面中可以说是比较重要的元素之一），那么就要从图片的大小上下手了，图片必须有一定的规范。首先轮播图的每个图片大小必须相同（或者说宽高比例相同），而且比例要适应浏览器，防止宽高比例不均的时候发生页面过大或过小的情况。我想这可能都是一些设计师的规范，而我对设计的领域了解并不深入，也许我想的是对的，也许是错的。但是这是我目前能想到的唯一解决方案。 使用background确实方便，但是为了网站的规范，我觉得有必要使用img标签。 结语没想到竟然整理了这么多，background元素属性虽然看起来简单，但整理之前真让我详细的说我并不能说出来十分确切的内容，整理之后觉得对这方面的内容了解得更加深入的许多。","link":"/background%E5%B1%9E%E6%80%A7%E5%92%8Cimg%E6%A0%87%E7%AD%BE/"},{"title":"npm的一些简单整理","text":"关于npm的使用一直不是很熟练，想要操作一些东西的时候总要查一下，觉得太麻烦了，所以这次就准备整理一下使用npm过程中的一些命令，以方便日后快速查询 全局安装和本地安装12npm install module-name # 本地安装npm install -g module-name # 全局安装 全局安装和本地安装区别 本地安装 将安装包放在 ./node_modules 下（运行npm时所在的目录） 可以通过 require() 来引入本地安装的包 全局安装 将安装包放在 /usr/local 下 可以直接在命令行里使用 删除依赖模块123npm uninstall module-name # 删除模块，但不会删除dependencies中信息npm uninstall module-name --save # 同时删除模块留在dependencies下的对应信息npm uninstall 模块 --save-dev 同时删除模块留在devDependencies下的对应信息 pockage.json介绍 每个项目的根目录下面，一般都有一个package.json文件，定义了这个项目所需要的各种模块，以及项目的配置信息（比如名称、版本、许可证等元数据）。npm install命令根据这个配置文件，自动下载所需的模块，也就是配置项目所需的运行和开发环境。 那么可以看出来package.json在项目中是很重要的，是一些配置信息，那么实际运行过程中可能需要一些包的支持，使用npm install即可完成安装。 将依赖模块添加到package.json中使用--save和--save -dev可以省掉手动修改package.json文件的部分，这里面就涉及到二者的区别了。 1npm install module-name --save 自动把模块和版本号添加到dependencies部分。而 123npm install module-name --save-dev #现在会报错，已被遗弃？npm install mudule-name --save --only=dev #新 自动把模块和版本号添加到devdependencies部分。 那么dependencies和devdependencies有什么区别呢？ 前者是项目运行时的依赖模块，后者则是项目开发时的模块。那么什么意思呢？项目运行意思就是在实际运行时候依赖的模块，而开发时候依赖的模块可以理解为开发时候依赖的模块，开发时候依赖的模块实际运行时未必需要。举个例子，比如说我使用less来写样式，最后编译成css，那么less就是我在开发时候依赖的模块，但是实际运行时侯并不需要less模块。 ———————2019.7.17—————– npm发布相关这个发布真的是花了不少时间。依次整理一下遇到的问题。 1. 2FA验证问题双重验证有三个模式，分别是只在登陆删除package的时候需要验证（较严格），还有发布等等时候也要验证（最严格），以及最后的无需验证。如何使用双因素身份验证 这里需要手机装个App，不过需要Google服务，最后手机直接下了个谷歌空间了事。 2. 发布仓库地址1npm config set registry http://registry.npmjs.org 后面可以根据需要自行改动，不过nrm可以管理npm仓库地址 12345nrm #展示nrm可用命令nrm ls #列出已经配置的所有仓库nrm test #测试所有仓库的响应时间nrm add &lt;registry&gt; &lt;url&gt; #新增仓库nrm use &lt;registry&gt; #切换仓库 3. publish Failed PUT 401发布的是已经存在的包，且不是发布者，就会报这个错，解决方法：加作用域。 即在package.json文件的name前面加上@用户名/，也可以使用命令行 1npm init --scope=@qxiaoqi -y 注意这里一定要是自己的用户名，不正确的话，会报403错误。 4. publish Failed PUT 402npm默认是私有发布，需要收费。公共发布命令行 1npm publish --access public 发布小结搞了半天终于搞好了，以致于发布成功之后收到邮件还有点小激动。。。","link":"/npm%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E6%95%B4%E7%90%86/"},{"title":"动手写一个hexo主题（上）","text":"自己写一个博客主题的想法已经很久了，而且加上想在找工作的时候能有一些拿得出手而且能体现我个人特点的作品出来，能体现出来具有代码能力+一点设计能力。感觉博客主题就是一个很好的作品。刚好之前用了一下ejs，了解了一下模板引擎的内容，觉得技术上已经具备的差不多了，于是开始动手实现了。在这里要感谢一下我的第一个博客主题yilia的作者，和indigo主题的作者，经常有一些不知道如何写的地方，查看了它们的主题源码。 前期准备首先确定技术栈：ejs+less+Jquery 基本的技术栈就是上面所说的内容了，hexo提供了很多方便的变量和辅助函数，更方便我们自己实现一个自己的博客内容。 项目结构主要介绍一下themes里面的结构，外面需要注意的就是一个_config.yml的文件，这个文件放了一些配置内容，yml文件即YAML语言，是一种用来写配置文件的语言，比JSON要更加的方便。 languages //语言文件夹，可放置一些语言（比如英语、法语之类的） layout //布局文件夹,用于存放主题的模板文件 _partial //放一些ejs和less的模板文件 archive.ejs //归档页面模板 index.ejs //主页页面模板 layout.ejs //整体模板，本目录下的其他的ejs会显示在body中 post.ejs //文章模板 tag.ejs //选中一个tag后的模板 tags.ejs //tags页面归档模板，这个是自己定义的 script //脚本文件夹，在启动时，Hexo 会载入此文件夹内的 JavaScript 文件 source //资源文件夹，例如 CSS、JavaScript 文件等 _config.yml //主题配置文件，有很多变量和辅助函数可方便博客内容的调用 设计主题由于我个人其实还是挺喜欢艺术的，之前也学了不少美术之类的东西，所以想把博客主题设计的有一些涂鸦的气息，想给人一种就写博客就像一种涂鸦的感觉。整个主题也构思了大概三天吧，大概讲一下我的设计思路，虽然不是说非常满意最后的设计，但是也基本满意了。 设计思路首先，是确定博客页面的整体结构，我看了很多博客。布局上主要分为两种，一种就是类似网站官网的那种直接从上到下的结构，还有一种就是类似yilia主题的这种左侧导航栏，右边是博客内容的这种。 这两种结构到底选择哪一种我也犹豫了好久，从艺术效果上考虑，我个人更倾向于第一种布局，因为这种布局给人发挥的空间很大，比如说banner部分可以提供一些炫酷的画面，留给我设计的空间很大。但是从功能上考虑，这次是要设计一个博客的主题，那么博客的作用是什么呢？方便查阅，方便阅读，文字优先，这些都是博客的功能。 作为一个博客，当然应该是功能优先，我在想，假如我是一个想查一些技术的用户，那么假设我打开第一种布局，可能我的第一印象是，哇这个网站好炫酷，好有感觉之类，但是多次进入之后可能就会觉得有点厌烦了，每次查东西都要往下拉，感觉很麻烦。假设我打开第二种布局，可能第一感觉并没有很惊艳的感觉，但是多次进入查阅技术的时候可能就会觉得很方便，每次进入都能很迅速的查到想查的内容。 然后就是确定整体基调了，有了上面的分析，那么基调也能很快确定下来了。简洁，涂鸦这两个词就是博客的主题。所以说留给我整体设计的可以说主要就是左侧的导航栏部分了，为了有涂鸦的感觉，当然就要找一些涂鸦的背景了，还有字体上要有感觉一些。还有一处，为了体现出来我的个性，我决定用鼠标画一个头像。 上面是从设计的内容考虑，但是作为一个技术人员，当然还要考虑实现了。设计完之后主要的问题就是两点。 第一点就是由于我使用github pages（买不起服务器_(:3」∠❀)_）所以这个页面的加载速度就成了一个问题，使用过多的图片会造成加载速度上的一些问题，以至于好长时间加载不出来页面。 第二个问题就是我在导航栏部分使用了网上下载的字体，倘若用户电脑里面没有（基本可以确定没有）用别的字体代替的话感觉会影响整体效果。那么解决方案目前想到两个，第一个就是使用font-face(还没用过),第二个就是使用图片了，但是第二个方案感觉最好还是不要使用了，加载速度太慢，而且导航栏部分是非常重要的内容，加载不出来的话很影响体验。 效果整体效果（PS设计稿） 构建脚手架之前不是很了解什么是脚手架，现在懂了，脚手架可以简单理解为快速的生成某种结构，可以大大减少工作量。那么这次就使用了yo这个工具，并使用generator-hexo-theme来快速构建项目。 注意，这里我遇到了一个坑，使用git bash的话会在选择技术栈的时候会出现选择错误的问题，改用cmd才成功。 hexo工作hexo提供了很多便利，在source文件夹下面写的css文件和js文件最终会编译到public文件夹的里面，然后在主题的config文件里面写上相应的public根目录下相应文件，然后在html中引入即可。然后ejs会自动编译，但是需要按照相应的名称命名。 gulp自动编译在写less的时候又遇到了一个问题，就是引入的css文件位置在/public/css/里面，然而我如果写在source里面写less的话每次都要hexo g一下，来生成静态页面（less会自动编译到public/css/graffiti.css里面），这样就很麻烦了。 解决方法，使用gulp来自动编译，每次监听less文件改动，然后自动编译到public/css/graffiti.css这里，这样就能在hexo server服务器开启的情况下f5刷新了，方便了很多。 但是这里又遇到一个问题，那就是我在很多博客的package.json配置里面看到比如说webpack这个包，都写在了/themes/[主题名称]/package.json里面，然而如果在主题文件夹里面使用npm安装相应的npm包的话，在hexo server时候会报错，原因就是这个node_modules文件夹不能在主题文件夹里面，那么问题来了，我究竟该怎么做？ 很明显，按道理讲webpack这个工具作为开发时候使用的，而在运行时并不需要，那就是说写在themes文件里面的devDependencies里面比较好。 gulpfile.js文件如下 12345678910111213141516171819202122232425262728var gulp = require('gulp');var less = require('gulp-less');var plumber = require('gulp-plumber'); //处理管道崩溃问题var notify = require('gulp-notify'); //报错与不中断当前任务//less编译gulp.task('less',function(){ return gulp.src('source/css/graffiti.less') //找到需要编译的less文件 .pipe(plumber({errorHandler: notify.onError('Error:&lt;%= error.message %&gt;;')})) //如果less文件中有语法错误，用notify插件报错，用plumber保证任务不会停止 .pipe(less()) //如果没错误，就编译less .pipe(gulp.dest('../../public/css/')) //把css文件放到hexo引用的css文件夹下});gulp.task('watchLess',function(){//监听所有less文件，如果有变化，则执行less编译方法 gulp.watch(['source/css/graffiti.less'],['less']);});//新建一个任务列表，把监听任务与服务器任务都放在列表中gulp.task('taskList', ['watchLess']);//修改默认任务gulp.task('default', function() { gulp.start('taskList'); //执行任务列表}); 那么动手写主题的前期准备基本完成了，下面就开始写主题了 主题部分整体左右两栏布局问题左侧栏用了position:fixed定位,脱离了文档流，并且固定左侧。这时候，如果右侧不使用absolute定位的话，当设置margin-top属性的时候，上面会被分裂，具体原因暂时还没研究，之前就出现过这个问题，等下一定要研究一下。可以使用BFC来处理。 那么右侧也要脱离文档流了，这时候，按照我原来的思路使用margin-left把左侧撑开，然后右侧使用width:calc(100% - 300px)来把右边固定宽度（因为不固定宽度的话，宽度会由其内部元素决定，但是内部元素不够宽的话会撑不起来整个屏幕）。 但是calc(100% - 300px)竟然失效，计算的结果竟然是-200%，我也很是懵逼，我还特意写了个小demo来测试，测试结果是成功的，但是这里竟然失效。那么，我做一个大胆的猜测，应该是hexo内部的一些代码的问题。 上面的方案行不通，那就另一个方案，使用border-box模型，来使用padding-left把左侧撑开，并设置width: 100%,完美成功了。 12345678.content-outer { position: absolute; // margin: 0 0 0 300px; padding-left: 300px; // width: calc(100% - 300px); width: 100%; z-index: -10;} 侧边导航栏导航栏的设计主要是一个大背景，然后从上到下分别是头像，昵称，导航菜单。然后会有一个选中效果。 悬停效果由于我想让选中后出现涂鸦的效果，涂鸦必然会显示到其他的li标签部分，所以在li处设置background明显不可以。为了达成这个效果，要写一个和a标签的兄弟元素，这个部分设置成绝对定位，通过js控制选中后显示出来。 hover伪类并不能达成这个效果，因为我的结构是选中a标签时其兄弟元素div显示，但是hover要么控制自身，要么控制其子元素，对其他并不支持（其实当为兄弟元素时，可以使用+号来控制，但是父元素就不行了，尽量还是js控制简单一点）。 同时，为了控制背景显示的位置，可以把其父元素li标签设置成relative来定位。然后就是计算图像的大小写width和height了。 HTML 123456&lt;% Object.keys(theme.menu).forEach(function(key) { %&gt; &lt;li&gt; &lt;div class=&quot;menu-hover &lt;%-key%&gt;-hover&quot;&gt;&lt;/div&gt; &lt;a id=&quot;&lt;%=key%&gt;&quot; href=&quot;&lt;%=theme.menu[key]%&gt;&quot;&gt;&lt;%=key%&gt;&lt;/a&gt; &lt;/li&gt;&lt;% }); %&gt; CSS 1234567891011121314//其中的一部分.Home-hover { position: absolute; width: 120px; height: 132px; left: 50%; margin-left: -60px; top: -30px; display: none; z-index: -5; background: url('../img/hover-1.png') no-repeat; background-size: 100%;} JS 123456789//其中一部分$(&quot;#Home&quot;).mouseenter(function() { // $(&quot;.Home-hover&quot;).css(&quot;display&quot;,&quot;block&quot;); $(&quot;.Home-hover&quot;).fadeIn(100); }); $(&quot;#Home&quot;).mouseleave(function() { // $(&quot;.Home-hover&quot;).css(&quot;display&quot;,&quot;none&quot;); $(&quot;.Home-hover&quot;).fadeOut(100); }); 以上就能实现悬停效果 非web安全字体这里我使用了一个网上下载的字体Yank，那么这个字体只是在我的电脑上能看见效果，在其它的电脑上就看不到了，那么如何解决这个问题呢。 在css3之前，那么程序员只能使用安全字体（就是说使用一连串的字体，其中一定有用户电脑自带的字体，比如说微软雅黑），这样字体就很局限，想用艺术的字体就只能用图片了。 那么现在css3有一个新的属性@font-face属性，这个属性能把字体放到服务器上，然后引入即可，例如： 在css中写上 1234@font-face { font-family: navfont; src: url('fonts/Yank.ttf');} 那么想引入的时候font-family: navfont;即可，由于我使用的github pages + hexo，所以把字体放入合适的位置就行了。 除此之外，google还提供一个Google Font Api来提供这么一个效果，上这么网站，然后找一款好看的字体，引入即可，比如说我想用Do Hyeon这么一个字体，用link引入即可，后面可直接使用 1&lt;link href=&quot;https://fonts.googleapis.com/css?family=Do+Hyeon&quot; rel=&quot;stylesheet&quot;&gt; 动手写一个hexo主题（下）","link":"/%E5%8A%A8%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AAhexo%E4%B8%BB%E9%A2%98%EF%BC%88%E4%B8%8A%EF%BC%89/"},{"title":"gulp整理","text":"在写hexo主题的时候，准备写一个自动编译的gulpfile文件，发现之前看的gulp相关内容并不很清晰，于是重新看了一遍，有了心得体会。 gulp.srcpipepipe的意思是管，然后gulp是流(stream)，之前使用的时候还不太懂pipe什么用，现在再看一遍终于有了一点感受。pipe可以理解为将流这个东西用管道将其引入别的地方。 举个例子，gulp文档里面的一段 gulp.src(‘client/templates/*.jade’) .pipe(jade()) .pipe(minify()) .pipe(gulp.dest(‘build/minified_templates’)); 首先解释一下，jade是一个模板引擎（现在叫pug），minify是一个压缩js和css的工具（比如说压缩成一行）。那么这段代码的意思就是将一个client/templates/下的所有jade后缀文件pipe到jade这个插件编译一下，编译成css文件，然后pipe到minify插件压缩一下，最后pipe到dest中输出到目标位置。 basebase也是一个比较有用的选项，可以控制base目录，也就是可以可以空输出的目录，详细可以查gulp文档 gulp.watch可以监听文件的变化，当文件发生了变化可以自己定义一些任务。举一个gulp文档的例子 var watcher = gulp.watch(‘js/*/.js’, [‘uglify’,’reload’]);watcher.on(‘change’, function(event) { console.log(‘File ‘ + event.path + ‘ was ‘ + event.type + ‘, running tasks…’);}); 那么意思就是监听js/\\**/*.js文件，当发生变化的时候执行uglify和reload任务，并输出一些信息。event.path出发该事件的路径，event.type是该文件的类型。 注意glob路径，之前就是因为这个问题导致我重新看了一边gulp文档，受益匪浅 后记其实有时侯还很犹豫要不要整理一些看似没必要整理的东西，其实这篇整理的时候主要是整理pipe的意义。有时侯我总以为我能记在脑子里，但是实际上，过一段时间我总是忘掉了。所以我觉得整理还是很有必要的，比如说这次的整理，我重新查了一些文档，感觉自己似乎懂了，但是当我尝试把它写在博客里的时候，我发现我并不是十分的清楚。当把它写完时，我发现我真的清晰了很多。所以不要犹豫是不是内容太简单了，或者浪费时间之类的，整理下来真的能提高很多。","link":"/gulp%E6%95%B4%E7%90%86/"},{"title":"动手写一个hexo主题（下）","text":"这个太长了，一篇文章整理不完，另开一篇 Home主页面tag随机颜色这个效果主要是tag标签随机一种颜色，然后每次打开它都是这种颜色。那么怎么实现这种效果呢？ 首先，我是想使用js获取随机颜色然后用js把颜色给加上。那么问题来了，颜色是随机了，但是每次打开颜色都不一样，这样体验感觉很不好。因此，我们要找一个关系来让他赋予相应的颜色。 首先我想的是根据首字母来划分一定区域，比如说选5种颜色，然后0-26均匀划分5段，但是，这样还有一个问题，英文字母自然没有问题，但是汉字呢，判断起来就很困难，网上也有一些插件，但是我觉得为了实现这么一个小功能就引入这么大的文件，感觉没有必要。 那么第二种就想到了根据长度，这个就简单很多了，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//================tag-icon颜色==========================var tagIcons = [ { &quot;id&quot;: 0, &quot;color&quot;: &quot;#fd0f02&quot; //红色 }, { &quot;id&quot;: 1, &quot;color&quot;: &quot;#42ba01&quot; //绿色 }, { &quot;id&quot;: 2, &quot;color&quot;: &quot;#8a1eff&quot; //紫色 }, { &quot;id&quot;: 3, &quot;color&quot;: &quot;#fe9402&quot; //橙色 }, { &quot;id&quot;: 4, &quot;color&quot;: &quot;#0136fe&quot; //深蓝 }]var getTagIcon = function(str) { var tagLength = str.length; if(tagLength &lt;= 4) { return tagIcons[tagLength - 1].color; } else { return tagIcons[4].color; }}var TagBackgroundColor = function() { var tagsAll = $(&quot;.article-tag-list-link&quot;); // console.log(tagsAll); tagsAll.each(function() { $(this).css(&quot;background-color&quot;, getTagIcon($(this).text())); })} post文章页面由于hexo把markdown的相应部分都渲染成了一定的class，那么直接定义class的样式就能显示出相应的markdown效果，比如说代码块、引用之类的。 代码高亮问题写这一部分真的心酸，我以为hexo的highlight功能开启了就能自己高亮了，实际上，凉凉。找了半天解决方法，也没找到，本来看到一篇博客引入了prettify高亮插件，但是想了想自己写一个拉到了。于是我本着自己动手的原则写了一套代码高亮的css（抄SegmentFault的代码颜色）。其实也没有想象中的艰难，hexo把一些关键字都取了类名，直接自己定一个颜色，字体大小什么的就ok了。 按照一般情况，代码高亮的原理是highlight.js这个插件（还有别的插件），这个插件什么用呢，【源码没仔细看】，分了很多语言，里面应该是用正则判断相应的语句，比如说#这个注释符号。获取到之后会赋予一定的class类名。 然后怎么高亮呢，很简单一个css文件就行了，相应的类名给予一定的css代码就可以了。 缩进问题还有一个部分就是缩进问题了，众所周知，空格是不会显示的，所以代码缩进在页面上预览的时候是不会出现的。这时候就要用一个white-space: pre-wrap;自动换行并且保留空格就行了。 图片过大问题有时候用markdown插入图片的时候没有指定宽度，这样太大会把页面撑开，如何解决呢？ 123img { max-width: 100%;} 解决方案很简单对吧。是的，但是不读别人的代码，我还真没有想到过。 Archives归档页面ejs结构这个页面参照了next主题的时间线效果，感觉这个效果很漂亮。这一部分实现起来有点小绕，为什么呢？ 如果直接与后端交互直接获取想要的数据自然没有这些问题，但是这次使用的是hexo，提供了很多便利的同时也有很多限制，本来hexo在archives提供的有一个插入函数就是list_archives这个函数，这个函数会直接插入按时间归档好的一推信息，那么我不仅想显示时间，还想显示文章，这样很明显就不能用这个函数，那么就只能foreach循环，并写一些逻辑来显示。 那么本着尽量少些js的想法（hexo+github不知道为什么有时候js文件在hexo d上传之后会莫名其妙删除），直接用ejs写 1234567891011121314151617181920212223242526272829303132&lt;div class=&quot;archives-block&quot;&gt;&lt;div class=&quot;achives-margin-left&quot;&gt;&lt;% var last; %&gt;&lt;% page.posts.each(function(article) { %&gt; &lt;% var year = article.date.year(); %&gt; &lt;% if (last != year) { -%&gt; &lt;% if (last != null) { -%&gt; &lt;/div&gt;&lt;/section&gt; &lt;% } -%&gt; &lt;% last = year; %&gt; &lt;section class=&quot;archives-wrap&quot;&gt; &lt;div class=&quot;archives-year-wrap&quot;&gt; &lt;a href=&quot;&lt;% url_for('archives/' + year ) %&gt;&quot; class=&quot;archives-year&quot;&gt;&lt;%= year %&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;archives&quot;&gt; &lt;% } %&gt; &lt;!-- 时间归档模板部分 --&gt; &lt;div class=&quot;archives-item&quot;&gt; &lt;span class=&quot;archives-item-time&quot;&gt;&lt;%= date(article.date,'M-D') %&gt;&lt;/span&gt; &lt;a href=&quot;&lt;%= url_for(article.path)%&gt;&quot;&gt;&lt;%= article.title %&gt;&lt;/a&gt; &lt;/div&gt; &lt;% }); %&gt; &lt;/div&gt; &lt;/section&gt;&lt;/div&gt;&lt;/div&gt; 这一段参考了yilia的作者的写法，这一部分如果只看标签的话，那么绝对是不会闭合的，因为这里面为了区分出不同年份一组的效果，使用了if判断一定条件，当满足时会将标签闭合，这样就能让不同年份的一组不在同一个标签组内。 前面的小圆点这一个效果使用before插入 123456789101112131415161718192021222324252627282930313233343536373839404142&amp;:before { content: &quot; &quot;; position: absolute; left: 0; top: 50%; margin-left: -4px; margin-top: -4px; width: 6px; height: 6px; background-color: #bbb; border-radius: 50%; border: 1px solid #ffffff; z-index: 5; transition-duration: 0.5s;}``` 其实很简单就能实现,注意使用absolute绝对定位，定位好相应的位置即可达成效果,后面的竖线效果同理。#### 前面的竖线这一部分本想用border-left实现，但发现会有多余的部分，不如使用absolute定位方便```css &amp;:after { content: &quot; &quot;; position: absolute; top: 42px; left: 0; margin-left: -2px; width: 4px; height: 100%; background-color: #f5f5f5; z-index: 1;} Tag标签归档页面这一部分没什么太多要说的，主要是一个页面布局的问题，由于使用了辅助函数，所以html结构就不是由我来决定，因此css布局上的方案并不是很恰当。这里由于不能使用calc函数计算，所以使用了在父元素使用padding和border-box来定位一个百分比宽度。内部a标签由于是内联元素，要想指定宽度，需要使用display:block来改成块级元素。 自己定义一个新模板这里我自己定义了一个新页面tags归档页面，本来hexo是没有带这个归档模板的，这里我使用hexo new page tags命令，然后会在hexo根目录下source中生成一个tags文件夹，里面会有一个index.md文件打开后设置相应内容即可，目前由于不需要更多的功能，所以添加一个layout: &quot;tags&quot;即可，这时在建立ejs文件就ok了 后记目前博客还存在一些问题，首先比如说页面加载速度太慢，应该是左侧导航栏图片加载太慢（应该是Github Pages比较慢？）还是比较影响体验的。之后放到码云上快多了。 还有一点，本来准备吧jquery全改了改成原生js（js文件只有两个3个函数），但是发现用了jquery之后人确实变懒了，本来函数都已经改过了，但是fadeIn和fadeOut两个函数因为太懒了，暂时不想改了，所以又全注释掉了。以后想改了再改回来吧。 还有个问题，就是这个页面的markdown居然解析错了，两个css代码段居然连在了一起？！！改了几遍也还是这样，目前暂未解决。","link":"/%E5%8A%A8%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AAhexo%E4%B8%BB%E9%A2%98%EF%BC%88%E4%B8%8B%EF%BC%89/"},{"title":"JS原型链","text":"前言最近有了点新的感触，如果想在前端上走得越来越远，那么我的核心竞争力在哪呢。之前总想着学着张鑫旭大神一样做一个偏前的前端，但仔细想想偏前的前端需求又有多少呢，而且也可能是我不想在复杂的代码中静下心来读吧，所以在js上的基础并不扎实。于是决定狠下心来重新研究一下js，本来想读一下jquery源码，但是发现js基础还是太差，很多东西读不懂，所以决定重新读一下js的基础语法部分。 js对象整理这篇文章的时候，又重新整理了一下之前写的js对象整理文章点击这里跳转 JS原型链JS原型链可以说是JS的核心属性之一了，那么什么是JS原型链呢。假设有一个对象o，这时候想查找o的属性x,即o.x，如果存在那么自然能直接返回，但是假如说对象o不存在属性x呢，这时候将会在o的原型对象中继续查找，若没有则继续向上查找，直到找到或原型是null为止。这样就形成了一个链，这个链就是js原型链。 继承说到原型链，那么就必须要提到继承这个功能，ES5中定义了一个方法,Object.create()方法，括号内两个参数，第一个是对象的原型。第二个可选，用来进一步描述，在JS对象整理一文中有提到。 实例 可以看到，定义了一个属性p继承自o 然后又定义了一个q继承自p，定义了s，这个toString()继承自Object，将p展开自_proto_，可以看到q的属性z，q的原型的属性y，以及q的原型的原型的属性x，以及最后的Object原型。 最后的结果展示了原型链的查找，q本来没有x和y属性，于是从其原型查找，最终找到，返回结果。","link":"/js%E5%8E%9F%E5%9E%8B%E9%93%BE/"},{"title":"2018-9-6小结","text":"从上一篇博客到今天已经过去了四个多月了，确实也是因为有点懒了，博客一直都没有更新。那么希望能重新拾起更新博客的习惯，更新博客就先从最近几个月的总结开始吧。 概括中间四个月我都做了什么呢，内容做的不多，但也做了一些内容。首先是参加了两次hackathon，然后接了两个外包项目。大概主要的内容就这么多吧，下面详细整理一下心得与体会吧。 自我剖析参加了两次hackathon比赛之后最大的感受是什么呢？没错，就是深感自己技术的不足，和其它很多人相比，感觉差距还是很大的。然后就是两个外包项目，采用的都是传统的Jquery那一套，非常的古老，对整个项目的结构写的非常的不满意，可读性，可维护性上面都很差。那么下面深入分析一下不足之处。 首先是对前端框架的方面，当时参加比赛的时候毫不避讳的讲，我的技术栈还是停留在Jquery的那种非常古老的技术层面上，框架一个没用过。 然后是前端自动化工具上只是用过比较简单的gulp，对webpack只是了解，从未使用过。 其次对整个项目的模块化上面完全没有头绪，Commonjs和AMD完全不了解。 然后在ES6上面也没有使用过。 还有对JS的使用层面还非常的浅显，之前更多的是对DOM的操作更多一些，逻辑上的东西也没有写过什么非常有逻辑的东西 CSS上面，最近在看一本书《CSS世界》，这本书豆瓣上评论褒贬不一，但是对我来说，只是看了几章，就感觉受益匪浅，对一些内在的原理也清晰了不少，CSS还是有很大的提升空间，一些技巧总能让我眼前一亮 项目的规范上面，两次外包都是和另一个后端合作，但是总是感觉流程不规范，比如说没有使用过git，感觉非常的不规范。 说实话自爆短处还是有点丢人的，也可能因为这一点我之前只是经常自己反省，但从来没有把这些不足之处拿出来讲过，导致对自己的能力认识不清楚。那么这次的一个简单的整理，也找到了很多的不足之处，那么接下来的时间当然是对这些问题一个一个的弥补了。外包项目也暂时不会再去做了，不然技术会一直停滞不前。 hackathon两次hackathon之行其中一次拿了悬赏任务奖，还有一次作品没有完成。但是不管哪一次，都收获很大，见了同龄人的技术栈，深感自己技术栈的浅显。 杭电hackathon杭电hackathon做了一个悬赏任务，内容是根据一个能获取人的心率，呼吸强度等信息的仪器，进行一个开发。那么我们最后的成品呢，一个就是将这些信息进行一个数据可视化的处理，另一个则是根据这些获得的数据，进行一个音乐的推荐。也算侥幸拿了个奖吧。 交大hackathon这次最后由于一些原因，并没有做出成品来，但是依然觉得非常的有意思。这次拿了一个ruff开发板，那么这个东西呢可以说和树莓派有点像吧，不过这个东西全部采用js来控制，那么作为一个前端，当然对这个非常的感兴趣。本来我们是打算根据这个东西来做一个智能家居里面的一个门禁的系统的，这个想法的由来则是源于杭电的hackathon中的一家赞助商的悬赏任务，但是最后由于一些原因没有完成。 外包两次外包呢，由于一些原因，不方便介绍具体的内容，也不方便贴图。这两个项目呢都是和气象相关的项目。整体实现起来呢，用比较古老的Jquery完全可以实现，并没有什么非常复杂的地方，但是也因为是外包项目，所以在其中并没有尝试一些新学的技术，而是采用了最稳妥的也是写的最多的Jquery那一套。但是项目中呢，也并不是没有收获，这两次项目写下来，深感项目结构的重要性，结构设计的不好，那么后面改起来工作量就会很大。一个好的结构设计，不仅看起来赏心悦目，后面的工作量也会大大减少。 总结那么简单的总结一下，四个月也算是没有闲着，虽然技术上提高不多，但是也开阔了眼界，深感自身水平的不足，希望能在半年里将上述的内容都逐一补起来。那么最后呢，就是对与外包项目的看法，适当的做一些还是有好处的，就比如说巩固所学，更加熟练的应用已有的技术栈，那么不好的地方呢，就是为了稳妥而不敢大面积尝试新学的技术，那么长此以往，技术得不到提高，最后依然会被淘汰。所以外包这件事情还是要掌握一个合适的尺度吧。希望从今天开始能重新整理起博客，积累自己。","link":"/2018-9-6%E5%B0%8F%E7%BB%93/"},{"title":"CSS-iScroll实现水平滚动实例","text":"前言最近在看《CSS世界》这本书，这本书其中的很多小技巧都让我有种眼前一亮的感觉，而且还有很多我之前不了解的一些语法，那么我会抽空将这本书上的一些小技巧，或者一些例子实现一下，加深印象。其中也会有一些自己的思考，以及学习这些知识时我发现的其它技术内容。 iScrolliScroll这是一个更多应用于移动设备的开发上的工具，能实现滚动效果、滑动等很多的效果，之前对这个工具并不了解。 具体实现 HTML123456789&lt;div id=&quot;wrap&quot; class=&quot;wrap&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;img src=&quot;test.jpg&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;test.jpg&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;test.jpg&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;test.jpg&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;test.jpg&quot;&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; CSS12345678910111213141516.wrap { margin: 200px; width: 300px; height: 200px; position: relative; overflow: hidden;}.wrap &gt; ul { position: absolute; white-space: nowrap;}.wrap li { display: inline-block;}.wrap li img { height: 192px;} JS123456// 这里需要引入iscroll.jsnew IScroll('#wrap', { scrollbars: true, scrollX: true, scrollY: false,}); 如果DOM还没有渲染完就执行iScroll初始化，会没有效果 如果你有一个复杂的DOM结构，最好在onload事件之后适当的延迟，再去初始化iScroll。最好给浏览器100或者200毫秒的间隙再去初始化iScroll iScroll使用的是querySelector 而不是 querySelectorAll，所以iScroll只会作用到选择器选中元素的第一个 iScroll所能实现的一些功能 scrollTo(x, y, time, easing)滚动到任意位置 scrollBy(x, y, time, easing)从当前位置相对滚动 scrollToElement(el, time, offsetX, offsetY, easing)滚动到特定位置 goToPage(x, y, time, easing)滚动到想要滚动的页面数（需在参数配置里设置snap） 当然还有一些别的功能，这里目前没有需求，所以就不列举其它的功能了。 总结那么从这个工具上来看，可以说是非常适合移动端的手指滑动了，而且动画效果非常的流畅。除此之外，想到了之前做的一个问卷平台，问卷平台的右侧有一个跟随题目生成位置不断移动的窗口，那么这里就可以通过iScroll来实现这种效果。","link":"/css-iscroll%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%B9%B3%E6%BB%9A%E5%8A%A8%E5%AE%9E%E4%BE%8B/"},{"title":"页面常用布局整理","text":"由于最近做的一个练习，用到了三栏布局，但是对其中的原理早就忘了，于是重新整理一番。 三栏布局三栏布局属于一种很常见的布局方式，字面上理解即分成三栏。由于各种原因，浏览器的大小并不完全相同，若将每一块设置成定宽，则不能兼顾各种尺寸。三栏布局即左右定宽，中间自适应，能适应很多需求。 1、左右浮动左右浮动的代码核心即采用float浮动方法，将左右两栏脱离文档流，而中间设置左右margin外边距，这样margin既能直接依照浏览器边缘做基准。HTML代码如下： 123&lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;&lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;&lt;div class=&quot;middle&quot;&gt;middle&lt;/div&gt; CSS代码如下： 12345678910111213141516171819.left{ float: left; background-color: blue; width: 100px; height: 100px;}.middle{ margin: 0 120px; background-color: yellow; height: 300px;}.right{ float: right; background-color: blue; width: 100px; height: 100px;} 需要注意的是注意HTML中左右栏与中间栏的位置，一定要将middle栏放在最后，因为浮动会脱离文档流。 该方法足够简洁，但是浮动的使用也添加了一些隐患。而且根据浏览器加载的规律，左右两栏会先于中间栏加载，倘若左右两栏加载过慢，影响用户体验。 2、圣杯布局圣杯布局主要采用margin负值来形成三栏布局，HTML代码如下: 12345&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;middle&quot;&gt;middle&lt;/div&gt; &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;&lt;/div&gt; css代码如下： 12345678910111213141516171819202122232425262728293031.container{ padding-left: 100px; padding-right: 200px;}.left{ float: left; width: 100px; height: 200px; background-color: #000AFF; margin-left: -100%; position: relative; left: -100px;}.middle{ float: left; width: 100%; height: 200px; background-color: #D3FF00;}.right{ float: left; width: 200px; height: 200px; background-color: #FF0000; margin-left: -200px; position: relative; right: -200px;} 圣杯布局的父元素container中的padding主要形成左右栏的框架。 若无position则会由于padding的控制而使左右空白，此时需要position:relative来调整左右栏位置。 若想将左右栏与中间栏有空位置，可将container中padding属性以及position的属性来调整。 此处跳转其他博客关于圣杯布局详解 3、双飞翼布局双飞翼布局是圣杯布局的改进，标签的使用更简洁，HTML代码如下: 12345&lt;div class=&quot;middle_body&quot;&gt; &lt;div class=&quot;middle&quot;&gt;middle&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;&lt;div class=&quot;right&quot;&gt;right&lt;/div&gt; css代码如下： 123456789101112131415161718192021222324252627.middle{ float: left; width: 100%; height: 200px; background-color: #F7FF00;}.inner{ margin-left: 100px; margin-right: 200px;}.left{ float: left; width: 100px; height: 200px; background-color: #0015FF; margin-left: -100%;}.right{ float: left; width: 200px; height: 200px; background-color: #FF0000; margin-left: -200px;} 双飞翼布局在处理三栏位置的时候与圣杯布局相同，都是采用margin负值。但是在中间内容遮挡的处理上不同。 圣杯布局采用position相对定位以及整个的padding来使左右两栏移动。 而双飞翼布局采用在中间元素中插入子元素，子元素包含了中间栏的内容，而在中间栏使用margin将两侧撑开。 若想将三栏之间留有间隙，则可将middle中的color移至inner中，再改动margin即可。 小结三栏布局时间已经很长了，但是其中的原理还是很值得研究的。除去三栏布局，我目前所熟知的布局还有bootstrap的栅格化布局（响应式布局），还有Flex布局。几种布局方式各有优劣，如何恰当的选取暂时理解不深，随着我不断的完成项目，应该能有更深的理解，期待我技术的不断进步。 —————————– 2019.4.8 更新 ——————————– 两栏布局1. float-marginfloat本身BFC，但是具有破坏性。而且虽然能不定宽（这里发现好多网上的都是错的，margin-left设置百分比是按照父元素来定的，也就是说可以不定宽，但是也有一点小问题，就是中间的间隙也是百分比，这个体验不是太好） 2. BFC方案优势：可以充分利用流体特性，左侧无论多宽，右侧BFC后，不会受其影响 而且可以整站替换，比如声明两个class，一个overflow：hidden，一个float：left。就可以整站使用 而float-margin需要知道左侧宽度而确定margin大小，没办法组件化。当然容器外面的元素有可能被隐藏，也算是一点小小的缺点吧 3. table-cell虽然是比较古老的布局吧，最开始也觉得这种布局很烂啊，什么的。但是后面也有了一点感触吧，真的是不同的布局有不同的优势，table布局简单，而且内部宽度设置的再大也不会超过表格容器宽度，也可以做一个自适应的block。而且最主要的是，天然支持等高布局 等高布局1. border模拟缺点，左侧定宽 优点：兼容性好 2. margin和padding组合margin-bottom：-9999px， padding-bottom：9999px，外部overflow：hidden隐藏 不足之处：子元素定位到外面会因为overflow：hidden产生一定问题","link":"/%E9%A1%B5%E9%9D%A2%E5%B8%B8%E7%94%A8%E5%B8%83%E5%B1%80%E6%95%B4%E7%90%86/"},{"title":"DDA算法和Bresenham算法画线","text":"最近正在看P5.js这个库，这个库可以说是Processing的JS版。这个库有一套作画功能，不仅仅能在canvas上画，还能把整个浏览器都当成画布。然后对前端数据可视化方向有一些兴趣，再加上开的一门课叫计算机图形学。多者结合，才有了这样一篇文章的整理。 DDA算法DDA算法原理DDA算法，是一种通过多个点连成一条近似直线的算法。众所周知，一个图像的显示是由无数个像素点构成的。那么，直线也不例外，也可以看成是无数个点的集合。 DDA算法即选出Δx和Δy中较大者作为最大步长，然后分别与Δx和Δy相乘得出每个方向上的单步步长，将第二个点的坐标算出来后，四舍五入近似成+0或+1。举个例子，根据上述公式可以看出，假若斜率小于1，每次x单步步长必为+1，此时只考虑y步长，算出y步长后加在上一个点上，然后使用函数进行近似，即可得出点的近似位置 DDA算法实现步骤 给出两点坐标 选出Δx和Δy中较大者作为最大步长 算出x轴和y轴的单步步长 循环画点 代码实现效果图 整体看似乎没有什么区别，那么放大看一下 放大看还是能看出比较明显的像素点的，反观line()函数画出的直线则几乎没有锯齿，目前还不清楚line()函数是如何实现的。 HTML12345678910111213141516&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;DDA算法绘制直线&lt;/title&gt; &lt;style&gt; body {padding: 0; margin: 0;} &lt;/style&gt; &lt;script src=&quot;../p5/p5.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../p5/addons/p5.dom.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../p5/addons/p5.sound.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./sketch.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; JS123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// sketch.jsfunction setup() { /* 原来对比直线 (600,100) 到 (1050,400) */ let o1 = { x: 600, y: 100 } let o2 = { x: 1050, y: 400 } /* 新画直线 (50,100) 到 (500, 400) */ let beginPoint = { x: 50, y: 100 }; let endPoint = { x: 500, y: 400 }; createCanvas(1200, 600); background(0); stroke(255); line(o1.x, o1.y, o2.x, o2.y); // drawLine(beginPoint, endPoint); let lineDDA = new Line(beginPoint, endPoint); lineDDA.drawLine();}function draw() {}class Line { constructor(beginPoint, endPoint) { // 求Δx和Δy(差) this.disX = endPoint.x - beginPoint.x; this.disY = endPoint.y - beginPoint.y; // 初始点 this.x = beginPoint.x; this.y = beginPoint.y; } // 最大差值 getMaxSteps() { return (this.disX &gt;= this.disY) ? this.disX : this.disY; } // 每次x像素移动长度 getStepX() { return this.disX / this.getMaxSteps(); } // 每次y像素移动长度 getStepY() { return this.disY / this.getMaxSteps(); } drawLine() { // 画初始点 point(this.x, this.y); // 循环画点 for(let i = 1; i &lt;= this.getMaxSteps(); i++) { this.x = this.x + this.getStepX(); this.y = this.y + this.getStepY(); point(Math.round(this.x), Math.round(this.y)); } }} Bresenham算法0&lt;k&lt;1情况下 Bresenham算法原理 d的递推式： Bresenham算法是对DDA算法的一种改进，避免了取整这一步。算法是通过判别式d的正负来判断直线与坐标轴相交的地方是在中点的上方还是下方（或者左侧还是右侧，根据斜率来判断选择哪一种方式）。倘若在0&lt;k&lt;1的情况下，得出d的值为负，则说明交点在中点上方，此时纵轴步长+1，否则纵轴步长+0。 Bresenham算法实现步骤0≤k≤1时 确定直线的两端点 计算初始值△x、△y、d=0.5-k、x=x0、y=y0 绘制初始点点(x,y)。判断d的符号,若d&lt;0，则(x,y)更新为(x+1,y+1)，d更新为d+1-k,否则(x,y)更新为(x+1,y)，d更新为d-k 重复步骤3 代码实现只有js部分的class部分内容有所改变，其它的都和DDA算法一样，固不再重复列举 效果图左侧是算法实现，右侧是函数实现 JS12345678910111213141516171819202122232425262728293031323334353637383940class Line { constructor(beginPoint, endPoint) { // 求Δx和Δy(差) this.disX = endPoint.x - beginPoint.x; this.disY = endPoint.y - beginPoint.y; //斜率 this.k = this.disY / this.disX; // 初始判别式 this.d = 0.5 - this.k; // 初始点 this.x = beginPoint.x; this.y = beginPoint.y; } // 最大差值 getMaxSteps() { return (this.disX &gt;= this.disY) ? this.disX : this.disY; } drawLine() { // 画初始点 point(this.x, this.y); // (k &gt;= 0 ) &amp;&amp; (k &lt;= 1) 情况下 if(this.disX &gt;= this.disY) { // 循环画点 for(let i = 1; i &lt;= this.getMaxSteps(); i++) { if(this.d &lt; 0) { this.x = this.x + 1; this.y = this.y + 1; this.d = this.d + 1 - this.k; } else { this.x = this.x + 1; this.y = this.y; this.d = this.d - this.k; } point(this.x, this.y); } } }} 总结这次的实现算是对第一次上图形学课的一点总结，也勉强算是初入图形学的一次入门级的实现吧。","link":"/dda%E7%AE%97%E6%B3%95%E5%92%8Cbresenham%E7%AE%97%E6%B3%95%E7%94%BB%E7%BA%BF/"},{"title":"CSS绘制三道杠和小圆点","text":"本文依然是对CSS世界中的小技巧的整理。看CSS世界的过程中，确实收获良多，有很多让人眼前一亮的小技巧。本文就将整理纯CSS实现移动导航中经常使用的三道杠，以及双层圆点的效果。无需加载图片实现。 三道杠border双线边框实现 HTMLHTML部分只有单层 1&lt;div class=&quot;icon-menu-border&quot;&gt;&lt;/div&gt; CSS12345678/* border 双线边框实现 */.icon-menu-border { display: inline-block; width: 120px; height: 20px; border-top: 60px double; border-bottom: 20px solid;} border-style: double属性是双线边框（至少3px才会生效），双线的宽度以及两条线之间的间距的分配是：双线宽度相等，中间间隔±1px 宽度和高度是指定的中间和下面两条线之间的位置，下方是单线边框，上方是双线边框 border颜色默认是当前color的颜色 padding和background-clip共同实现 HTMLHTML部分只有单层 1&lt;div class=&quot;icon-menu-padding&quot;&gt;&lt;/div&gt; CSS1234567891011/* padding和background-clip共同实现 */.icon-menu-padding { display: inline-block; width: 140px; height: 10px; padding: 35px 0; border-top: 10px solid; border-bottom: 10px solid; background-color: currentColor; background-clip: content-box;} background-clip设置元素背景区域，有三个参数border-box（默认）:背景延伸到边框外沿（但是在边框之下）。padding-box:边框下面没有背景，即背景延伸到内边距外沿。 content-box:背景裁剪到内容区 (content-box) 外沿 宽高定在中间位置，上下padding，外层边框，通过background-clip属性将背景颜色区域限制在内容区，而padding区没有颜色 currentColor属性表示当前标签所继承的文字颜色，其中有一些妙用，比如说张鑫旭博客里面的背景色镂空效果 :before和:after伪类实现这个是我在书上看到说可以通过伪类实现三道杠效果，但是并没有给出实例，我就自己想了一下，写了一个，未必是最佳写法。 HTMLHTML部分最外层是用来指定一个选区大小，否则选区只是middle该区域的大小 123&lt;div class=&quot;icon-menu-demo&quot;&gt; &lt;div class=&quot;middle&quot;&gt;&lt;/div&gt;&lt;/div&gt; CSS12345678910111213141516171819202122232425262728293031323334/* :before和:after伪类实现 */.icon-menu-demo { position: relative; display: inline-block; width: 120px; height: 100px; cursor: pointer;}.middle { width: 120px; height: 20px; background-color: currentColor;}.middle:before { position: absolute; top: 40px; width: 120px; height: 20px; content: &quot;.&quot;; color: currentColor; background-color: currentColor;}.middle:after { position: absolute; top: 80px; width: 120px; height: 20px; content: &quot;.&quot;; color: currentColor; background-color: currentColor;} middle位置在最上面，:before在中间，:after在最下面，原因是为了便于外层包裹的div确定区域 color和background-color颜色要相同，将伪类的文字内容隐藏 小圆点 HTML1&lt;div class=&quot;icon-dot&quot;&gt;&lt;/div&gt; CSS12345678910.icon-dot { display: inline-block; width: 100px; height: 100px; padding: 10px; border: 10px solid; border-radius: 50%; background-color: currentColor; background-clip: content-box;} 和上面的padding和background-clip实现三道杠效果原理相同，不再赘述 总结可以看出来，我自己想出来的伪类实现三道杠和其它两种方法比起来繁琐了许多。总之，看了CSS世界这本书，确实收益颇多，后面也会抽空整理一下书中的其它一些小的技巧，巩固所学。相比于加载图片，这种方法确实优秀了许多。","link":"/css%E7%BB%98%E5%88%B6%E4%B8%89%E9%81%93%E6%9D%A0%E5%92%8C%E5%B0%8F%E5%9C%86%E7%82%B9/"},{"title":"内联元素的一些探究","text":"本文依然是对《CSS世界》这本书中的一些知识点进行探究和实践。内联元素在CSS中极为重要，块级元素负责结构，内联元素负责内容，而CSS又是为图文展示而设计，因此显得尤为重要。同时多个属性混合在一起共同作用又会产生较为复杂的结果，比较典型的就是line-height和vertical-align，以及“幽灵空白”（CSS文档中叫strut）产生的一些现象了。 文中也将从这三个方面去入手，实践一些现象产生的原因。 幽灵空白“幽灵空白”这个概念并非没有意义，内联元素中产生的很多看似很难解释的现象其实很多都和这个“幽灵空白”息息相关。 证明幽灵空白存在 line box starts with a zero-width inline box with the element’s font and line height properties. We call that imaginary box a “strut.” 上面是一段对strut的描述，书中将其称为幽灵空白，表现为看不见摸不着，但却真实存在，可以用一段代码证明其存在。 123&lt;div&gt; &lt;span&gt;&lt;/span&gt;&lt;/div&gt; css代码如下 1234567div { background-color: #000000;}span { display: inline-block;} 从上图可以看出来，其中并没有内容，内部的span宽高也都是0，但是div的高度却并不为0，而是20.8px，即可以认为span元素前面还有一个宽度为0的空白字符，那么都可以解释通了。 Line boxes that contain no text, no preserved white space, no inline elements with non-zero margins, padding, or borders, and no other in-flow content (such as images, inline blocks or inline tables), and do not end with a preserved newline must be treated as zero-height line boxes 同样还要注意，这里display要指定为inline-block,否则按照上述文档的描述，高度会被视为0 这里为什么是20.8px呢？根据我的理解，这里的20.8px即内容区域（content area），即内联盒模型中的一个不可见区域。根据《css世界》作者的理解与实践，可以将其理解为文本选中背景色区域。 这里内容区域是由font-family和font-size共同决定的,可以做一个测试，比较设置font-family: simsun和不设置时的区别。（默认为微软雅黑） 1234div { background-color: #000000; font-family: simsun;} 设置之后，高度变为18.4px 即内容区域的高度和字体相关。当然这里还是有一个疑惑，设置宋体之后，内容区域应该和em-box相同，按照默认16px，高度应该是16px而非18.4px。这里暂未找到原因。 line-heightline-height属性可以说是内联元素的基石 决定非替换元素的高度决定高度要分成两部分来讲，对于替换元素和非替换元素来讲是不同的 非替换元素对于非替换元素（替换元素比如img）的内联元素来将，其高度是由line-height决定的。比如说一个&lt;div&gt;&lt;/div&gt;是高度为0，当写上几个字之后就有了高度，但是这里的高度并非由font-size决定，而是由line-height决定的。可以用代码测试一下。 123456&lt;div&gt; &lt;div class=&quot;test1&quot;&gt;高度&lt;/div&gt;&lt;/div&gt;&lt;div style=&quot;margin-top: 20px&quot;&gt; &lt;div class=&quot;test2&quot;&gt;高度&lt;/div&gt;&lt;/div&gt; css代码如下 12345678910111213.test1 { font-size: 16px; line-height: 0; border: 1px solid #ccc; background-color: #eee;}.test2 { font-size: 0; line-height: 16px; border: 1px solid #ccc; background-color: #eee;} 可以看到，上面font-size为16px的只有border撑起来的2px，而下面的line-height为16px的则是一共18px的高度。由此可以得出结论，内联元素的高度是由line-height来决定的。 替换元素对于替换元素来讲，比如说图片，设置其容器的line-height并不会影响到图片，但是由于图片为内联元素，前面也然会有一个幽灵空白，所以会造成容器被撑大的现象，但并未影响到图片。 只有在非替换元素下，才能决定高度，在混合情况下，比如说图文混排时，则只能决定最小高度，不仅是替换元素不受line-height影响，同时也有vertical-align的影响。 行距行距是内容排版上很重要的一点，但是由于平时开发中，也都是看着差不多就行了，并没有对其中的实现有所了解。这里也通过行距来进一步理解line-height在内联元素中重要的作用。 行距在css里是分成上半部分和下半部分的，即第一行文字上面也是会有一半行距的。行距的计算公式即行距 = 行高 - em-box，简单讲就是行距 = line-height - font-size。 这里要注意一点，内容区域和em-box不一样，内容区域受font-family和font-size共同决定的，而em-box只受font-size决定，所以你会发现，设置不同的字体，同样的font-size，按照公式计算的话行距是一样的，但是肉眼看到的行距似乎却并不一样。 但是有一个字体例外，宋体的内容区域和em-box的区域是等同的。 123&lt;div class=&quot;test&quot;&gt; &lt;span&gt;sphinx&lt;/span&gt;&lt;/div&gt; css代码如下 123456789.test { font-family: simsun; font-size: 80px; line-height: 120px; background-color: yellow;}.test &gt; span { background-color: white;} 行距即上下两边黄色的部分，这里可以做一个测试，将字体改为微软雅黑之后 可以明显的看到，内容区域的高度并不一致。 内联元素垂直居中单行文字这里要纠正一个之前一直犯的错误，单行文字垂直居中只需要line-height即可，并不需要画蛇添足加一个height。 举个例子，一个高度为50px的标题垂直居中 123456.title{ /* height: 50px; */ line-height: 50px; background: #000; color: #fff;} 并不需要注释掉的那一行 多行文字或替换元素这里需要line-height和vertical-align共同作用 123&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;content&quot;&gt;基于行高实现的多行文字垂直居中效果，垂直居中效果&lt;/div&gt;&lt;/div&gt; css代码如下 12345678910111213.box { width: 280px; line-height: 120px; background-color: #f0f3f9; margin: auto;}.content { display: inline-block; line-height: 20px; margin: 0 20px; text-align: left; vertical-align: middle;} 这里需要解释一下原理 box里的width和margin共同作用外部容器水平居中 box里的line-height决定容器高度 content里的display很关键1 这里重置了外部line-height大小，不能指定为block等块级元素，需要保持内联元素特性，因为需要使用vertical-align属性2 同时产生行框盒子及幽灵空白。这里需要幽灵空白被box的line-height作用，撑开外部容器。 vertical-align: middle是为了调整对其方式，默认向基线对齐，需将其改成近似居中对齐 line-height的大值特性大值特性，其实内在原因同样是由于幽灵空白的作用。举个例子 123456&lt;div class=&quot;box box1&quot;&gt; &lt;span&gt;span: line-height:30px&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;box box2&quot;&gt; &lt;span&gt;span: line-height:96px&lt;/span&gt;&lt;/div&gt; css代码如下 12345678910111213141516171819202122.box { width: 280px; margin: 1em auto; outline: 1px solid #beceeb; background: #f0f3f9;}.box1 { line-height: 96px;}.box1 span { /* display: inline-block; */ background-color: #ddd; line-height: 30px;}.box2 { line-height: 30px;}.box2 span { /* display: inline-block; */ background-color: #ddd; line-height: 96px;} 可以看到box容器高度都是96px，那么解释一下原因，还是由于幽灵空白，span元素前面可以假设把它加上一个x匿名内联元素。 加入是外部设置line-height为96px，那么则是作用到了x这个幽灵空白上，倘若是子元素设置了line-height，则是作用到了子元素的行框盒子上。整体行框盒子由最大的决定，因此还是96px。 如果想避免幽灵空白的干扰，将上面注释掉的代码恢复，即设置inline-block创建一个独立的行框盒子，就能将里面的子元素不受干扰。同时满足大值特性 vertical-align说到这个属性，就要提到基线，这也是很多现象产生的原因，比如说vertical-align: middle其实是近似垂直居中。 而这近似垂直居中又导致了很多现象的出现，比如说很常见的一个布局，一行字加上一个下拉符号 设置的都是20px大小，而且也使用了vertical-align: middle，但是最后的结果整个容器总是要大于20px，原因就和基线的定义有关了，如下图所示 那么基线的定义就是字母x的下边缘，middle则是指基线往上1/2的x-height的位置，可以理解为x中间的那个交点。看似没有什么问题，但实际上问题就由此产生，每个字体在行内盒子的位置是不一样的，上面也比较了微软雅黑和宋体两个字体的差异，可以明显发现微软雅黑字体会下沉，那么也就导致了middle和实际的中线位置会往下偏一点。那么这个偏一点具体偏多少由font-size的大小决定，越大则下沉的效果越明显。所以实现真正意义上的居中是很困难的。 拿一个作者博客的例子 可以很明显的看到，确实如我上文所说，要想实现真正意义上的垂直居中，可以设置font-size为0，这样x就缩小为一个点，就能实现垂直居中效果，当然开发中并非一定要真正实现这种，一般情况下也看不出来 单行文本高度不等于行高现象123&lt;div&gt; &lt;span&gt;123&lt;/span&gt;&lt;/div&gt; css代码如下 123456789div { background-color: #000; line-height: 32px;}span { color: #fff; font-size: 24px;} 可以看到如图中所示，高度并不为32px，出现这一现象也是由于vertical-align以及幽灵空白作用的结果，理解这一现象本质，有助于理解内联元素。 这似乎与上面行高决定非替换元素的高度这一观点相矛盾，其实并非如此，很多现象都是很多属性共同作用的结果。这里产生的原因就是子元素设置了font-size属性，导致和父元素字体大小不同，而内联元素又是和基线对齐，导致错位。 我们可以在span前面加上一个x作为匿名内联盒子，在span里面加上一个x作为内联盒子 可以看到，本来匿名内联盒子的x位置好好的，但是由于内联盒子字体太大了，导致为了基线对其，而将文字上移，就把父级容器撑开了，导致高度大于32px也就是这个原因。 解决方案很简单，原因是font-size产生的，自然可以从字体大小上改动，指定父元素的font-size为24px与子元素相同，就能使高度为32px 图片底部留有间隙现象这个现象可以说是从我刚开始学css起就遇到过了，结果之一也就不了了之了，只知如何解决，却不理解产生这种现象的原因。 123&lt;div class=&quot;box&quot;&gt; &lt;img src=&quot;1.png&quot;&gt;&lt;/div&gt; css代码如下 123456789.box { width: 280px; outline: 1px solid #aaa; text-align: center;}.box &gt; img { height: 96px;} 可以看到，按照代码来看，应该是容器被图片撑开，然后是96px才对，然而实际确实100px，产生间隙的原因很多情况下都是line-height，vertical-align，幽灵空白造成的，此处也不例外 这里和前面一样加上x，并添加上背景色辅助观察。可以很明显地看到产生间隙的原因，内联元素中，图片的基线按照下边缘来决定。 因此，图片下边缘和x下边缘对齐，那么下边的间隙就是半行距，没错，间隙就是半行距撑开的。既然知道了产生的原因，那么解决起来就很简单了，消除半行距即可。比如让父元素line-height足够小，另行距为0或者是负值，即可解决。当然，也可以直接消除幽灵空白，将图片块状化，幽灵空白就消失了。或者改变对齐方式也可以解决。 总结css看似简单但也确实是有很多值得去探讨的地方，理解内在的原理也许才能更好的设计出更加合理的布局。","link":"/%E5%86%85%E8%81%94%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8E%A2%E7%A9%B6/"},{"title":"解决回调地狱","text":"文中将简单整理一下js异步编程的方法。关于js异步编程，早期很容易出现回调地狱这一现象，也出现了一些相应的解决办法，从Promise到Generator再到async/await,解决了回调地狱这一问题，当然本文只是浅显的举出一些实例，以及个人简单的理解。 异步编程这一块确实还有很多可以继续深入的地方。 异步编程方法 回调函数 事件监听 Promise对象 Generator函数 Generator的语法糖async/await 文中将着重放在Promise，Generator函数，async/await这三个方面进行举例 回调地狱产生这里首先使用node随便写三个接口测试，具体代码就不贴了，两个Get请求，一个Post请求。 123456789$.get(url + &quot;/first&quot;, function(resFirst) { console.log(resFirst); $.get(url + &quot;/second&quot;, function(resSecond) { console.log(resSecond); $.post(url + &quot;/login&quot;, userData, function(res) { console.log(res); }) })}) 可以看到上面代码就是一个简单的回调地狱，每一个请求都是外层请求的回调。那么有什么问题呢？最明显的一点就是，代码可读性差，就像洋葱一样一层包裹着一层，改动一处，其余地方也要改动，可维护性也不好。 当然回调地狱不止是这么一个问题，还有一个问题就是异常处理上的问题，即在回调中出现的异常无法被捕获，举个例子 1234567891011function throwError(){ // console.log(&quot;throw&quot;); throw new Error('ERROR');}try{ setTimeout(throwError, 3000); // throwError();} catch(e){ alert(e);//这里的异常无法捕获} 上面代码运行后并不会弹出窗口，也就是无法被捕获到，那么类比到最开始举的三个请求的例子，我们不能直接在三个请求整体的外面写try/catch，因为这样无法捕获，而需要在每个回调内部写才能捕获到，如下 123456789101112131415161718192021222324$.get(url + &quot;/first&quot;, function(resFirst) { console.log(resFirst); try { throwError(); } catch(e) { alert(e); } $.get(url + &quot;/second&quot;, function(resSecond) { console.log(resSecond); try { throwError(); } catch(e) { alert(e); } $.post(url + &quot;/login&quot;, userData, function(res) { console.log(res); try { throwError(); } catch(e) { alert(e); } }) })}) 这样代码的弊端非常明显，代码量不仅大，而且异常非常不方便处理，那么下面就将使用Promise改写该段代码，解决上述问题。 Promise改写Promise是一种异步编程解决方案，有三种状态pending，fulfilled，rejected，使用Promise就可以让上面的代码异步操作以同步操作的流程写出来，避免过多嵌套，每一个then都可以当成回调，根据链式调用，其参数是上一个取决于上一个链发送的参数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 封装的请求const reqJSON = function(url, data) { const promise = new Promise(function(resolve, reject){ // 箭头函数不会创建this，而是向上找 const handler = function() { if (this.readyState !== 4) { return; } if (this.status === 200) { resolve(this.response); } else { reject(new Error(this.statusText)); } }; const client = new XMLHttpRequest(); if (data === null) { // get请求 client.open(&quot;GET&quot;, url); client.onreadystatechange = handler; client.send(null); } else { // post请求 client.open(&quot;POST&quot;, url); client.onreadystatechange = handler; client.responseType = &quot;json&quot;; client.setRequestHeader(&quot;Content-Type&quot;, &quot;application/json&quot;); client.send(JSON.stringify(data)); // client.send(data); } }); return promise;};// Promise改写new Promise((resolve, reject) =&gt; { reqJSON(localUrl + &quot;/first&quot;, null) .then(json =&gt; { console.log('Contents: ', json); // 上面reqJSON()封装的请求里面的resolve代表的是封装的成功，两者不一样 // 下面的resolve代表请求成功后成功（可以理解为收到200后） resolve(); // reject(&quot;first接口报错&quot;); })}).then(data =&gt; { return new Promise((resolve, reject) =&gt; { reqJSON(localUrl + &quot;/second&quot;, null) .then(json =&gt; { console.log('Contents: ', json); resolve(); // reject(&quot;second接口报错&quot;); }) })}).then(data =&gt; { return new Promise((resolve, reject) =&gt; { reqJSON(localUrl + &quot;/login&quot;, userData) .then(json =&gt; { console.log('Contents: ', json); resolve(); // reject(&quot;login接口报错&quot;); }) })}).catch(err =&gt; { console.log(&quot;捕捉到error:&quot;, err);}) 上面代码的上部分是使用Promise实现Ajax操作，下部分则是三个请求，虽然还是有点丑，可以进一步封装，但是确实把嵌套打开了。并且最重要的是异常捕获没有问题，resolve代表可以继续往下进行，reject则表示出错，只需要在最后面写上catch既可以全部捕获 Promise实现原理这里照着链接敲了一遍，然后自己打断点跑了几遍，也算是理解了Promise的大致实现流程。 首先分析一下，Promise一共三种状态，pending，resolved，rejected三种状态，然后常用方法两种then和catch。那么我们要做的就是将这些逐个实现。 首先就是构造函数的编写，这里就不贴代码了，想看代码得可以去上面链接自己敲一遍。由上述可得，内部属性status用来存三种状态，data用来存resolve传入的数据。然后Promise接收的参数是一个函数，函数有两个参数，分别是resolve和reject两个方法。因此，构造函数还需要实现resolve和reject两个方法，方法功能是调用后将状态改变，以及将resolve或reject的参数存入data。这里有一个要注意的地方就是，Promise的状态一经改变，就会凝固，不会再改变了。所以这里要注意一下。 然后就是then方法的实现，then方法接收两个参数，一个是成功回调函数，一个是失败回掉函数。而且这里的then返回的是新的Promise实例，但是属性还是之前的数据，原因是，假如是同一个对象，那么假如then的promise抛出一个异常的话，状态就变成了rejected，这就违背了Promise状态一经改变就不会再变的原则。之后then内部会调用传入的回掉函数，并改变此时的promise对象属性。 需要注意的一点是，new Promise(resolve =&gt; resolve(8)).then().then((value) =&gt; console.log(value)})这种情况下需要值穿透，方法就是假如then不传参数的话，我们默认给它一个参数，让其return自己，就能实现值穿透。 catch方法的话实现起来就比较简单了，直接调用then(null, onRejected)即可。 这里有一点要注意的，就是之前构造函数里还有两个属性_self.onResolvedCallbacks，_self.onRejectedCallbacks这两个属性分别是数组，存的是函数。之前一直不了解两个属性的作用。后来仔细查看之后，这两个属性存的是状态pending情况下的回调。那么是什么意思呢，意思就是说当触发then方法的时候，status有可能是pending状态，那么这个时候并不知道是要调用成功回调还是失败回调。拿方案就是都存下来，当后面状态改变的时候，当触发resolve时，会遍历callback数组，并执行函数。我们可以用一段代码，打断点测试一下，如下 1234567891011121314151617181920const promise = new MPromise(function(resolve, reject) { console.log(&quot;MPromise&quot;);});promise .then(response =&gt; { console.log(response); console.log(&quot;then回调&quot;); })promise.resolve(&quot;second&quot;);promise .then() .then(response =&gt; { console.log(response); }) .catch(error =&gt; { console.log(error); }) 上述代码的第一个then时，状态还是pending，就会触发存入callback的操作。而且后面有一个无参数的then，可以测试值穿透的情况。 那么实现原理大概就是这样了，自己动手写一遍就很清楚了。其实我上面讲的肯定很乱，没有代码空口白说，直接看估计也看不懂。主要是为了自己梳理一下思路吧，想具体了解原理的请点上述链接自行查看。 Generator改写Generator封装了多个内部状态，其使用next()来继续运行，使用throw()来抛出错误。内部使用yield来定义内部状态 123456789101112131415161718function* reqFun() { try { yield reqJSON(localUrl + &quot;/first&quot;, null) .then(json =&gt; { console.log('Contents: ', json); it.next();}) yield reqJSON(localUrl + &quot;/second&quot;, null) .then(json =&gt; { console.log('Contents: ', json); it.throw(new Error('error'));}) yield reqJSON(localUrl + &quot;/login&quot;, userData) .then(json =&gt; { console.log('Contents: ', json); it.next();}) } catch(e) { console.log(e); }}let it = reqFun();it.next(); 代码如上图，发送请求依然是用上面Promise封装的ajax操作，优点代码更加简洁，而且也解决了在外部使用一个try/catch就能捕获内部所有状态 其中需要手动执行函数，并使用next()让其继续运行。当然可以使用co模块让其自动运行，这里就不再赘述 async函数改写async函数使异步操作更加方便，简单讲就是Generator函数的语法糖，其内置了执行器，会自动执行结果 12345678910111213141516async function reqFun() { try { await reqJSON(localUrl + &quot;/first&quot;, null) .then(json =&gt; { console.log('Contents: ', json);}) await reqJSON(localUrl + &quot;/second&quot;, null) .then(json =&gt; { console.log('Contents: ', json); throw new Error(&quot;error&quot;);}) await reqJSON(localUrl + &quot;/login&quot;, userData) .then(json =&gt; { console.log('Contents: ', json);}) } catch(e) { console.log(e); }}reqFun(); 和上面Generator改写的很相似，async有更广的适应性，其返回值是Promise，也就意味着定义的reqFun()函数可以继续then()或者catch()，可以构造更加合理的代码结构 总结文中只是整理了一下基本的使用，以及自己的一些见解吧，也参考了很多博客。也算是对ES6的一些内容的进一步实践吧","link":"/%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1/"},{"title":"记一次项目的优化","text":"性能很重要，所以优化一直是一个很大的话题。而且根据项目和需求的不同，优化的策略也不同。项目优化之前做的一直不多，这次着手准备优化一下之前写的一个项目。 字体渲染优化分析先贴一张最开始的分析图 首先分析优化的方向，打开Network分析一下资源的加载情况，可以非常明显的看到字体加载上花了很长时间，平均加载8s，甚至更久。也因此在用户没有缓存的情况下，由于字体没有加载出来，而导致字体出现时间比其它DOM出现时间晚的多，而且首屏加载所等待的时间较长。因此，首先优化字体的渲染势在必行。 方案分析出来首要优化目标之后，就是针对情况进行优化。其中我发现了一个现象，按道理讲字体渲染出来应该是在字体文件加载完毕之后才会出现。但是实际情况并非如此，而是大致在其它DOM出现后的近4s时就已经出现了。 由于首页（登录页）字体比较少，我并未发现此时渲染出来的字体和下载字体的区别。直到偶然看一些字体优化策略的文章之后才发现，浏览器实行的是FOUT和FOIT策略（文章上讲IE和Edge实行FOUT策略，其它实行FOIT策略），但我经过测试Chrome下并非完全的FOIT策略，而是采取FOUT和FOIT折中的策略。即3s内如果字体加载出来，那么加载出来之前隐藏文本，如果3s内没有加载出来，那么则显示降级字体。 那么此时了解了浏览器对字体渲染的策略之后，就可以下手了。项目里引入了fontfaceobserver，一个字体加载器。可在字体加载完后，执行编写的js。 我们几乎可以确定，在无缓存情况下，3s内Chrome下字体文件加载不出来（Chrome需要近7s，而Firefox仅需2s多）。即使能加载出来，也需要一定时间，和其它DOM显示有一定时间间隔。那么如何让他们同时渲染出来？中间也考虑了几种方案 方案一：登录页默认使用安全字体，0.5s内如果能加载出来下载字体，则使用下载字体，否则登陆页就使用安全字体。 该方案其实就是FOIT策略的变形，不过不同之处是加载不出来就不换了（因为登录页就没几个字，字体切换如果不细看的话几乎看出来。）但是并不是FOIT策略，因为使用FOIT策略的话，字体切换虽然不细看看不出来，但是假如用户在填写账号密码的时候字体发生了切换，那么这个时候是非常明显的，几乎可以很明显的察觉到字体抖动，体验非常不好。因此我将时间点缩到了0.5s（如果有字体缓存，那么还是可以直接使用下载字体）。 这个方案虽然比较合适，但是这个方案也有缺点，大部分情况下（用户进入时是有字体缓存的），那么登陆页在0.5s时会发生一个轻微的字体抖动，虽然在不知情的情况下几乎察觉不出来，但在我看来仍不是一个最佳方案。 方案二：登录页默认使用下载字体，如果0.5s内不能加载出来，那么则使用降级安全字体。 该方案是方案一的另一种思路，也就是FOUT的变形，不同之处是将3s缩减到了0.5s，经过多次测试之后，缩减到了0.1s，0.1s在有缓存的情况下足以加载出来（再小的话有缓存也加载不出来）。该方案可以说D字体和其它DOM同时出现，可以说是体验非常好了。而且等用户将登录信息填写完整之后，字体已经加载好了，进入内容页直接就是下载字体。 其它同时在这一阶段，将ttf字体转成了woff2和woff，直接缩小了一半多。同时也将图片进行了压缩，同样压缩了一半多。同时服务端又开启了gzip将js和css文件进一步压缩，加载速度又提升了一截。中间也用了uglifyjs试图进一步压缩js，但是效果并不明显，应该是编译之后已经压缩过一次的缘故。 贴一下第一阶段优化之后的加载情况 可以看到，提升了很多，几乎可以说是天壤之别。但其实除了字体渲染策略上考虑了一番以外，别的对资源的压缩之类的并没有花很多功夫，但是提升确实是很显著的。因此静态资源的压缩确实是对优化项目有很大的提高。 懒加载分析首先，项目可以简单分为前台页面（一般用户使用的），以及后台管理页面（管理员管理上传之类的）。那么，此时采用单页应用就存在一个问题，那就是，对于普通用户来讲，是不需要进入后台的，但是单页应用不做处理的时候，在首屏直接会将所有文件加载，这对用户体验来讲，是不合适的。因此，需要进行更改。 方案1：懒加载，即将后台的一个大组件以及其包含的三个组件懒加载，令其空闲时加载，减少首屏引入的包体积。 先放一张拆分后的结构，当然经过拆分后发现其实我把问题想简单了，想当然的觉得将共用的抽离出来是最优解。但其实未必，后面也将写一些优化过程中产生的一些想法。 这里vue-cli默认为初始化渲染需要的文件生成preload提示，即预加载。我们这里使用vue-router的懒加载，vue-cli会将将异步组件单独打包生成chunk，并添加prefetch提示，打开network分析可看出，带有prefetch的会在后面加载，当用户进入后台时，此时发起的请求会直接从缓存中拿出来。 中间也发现了一个小问题，发现在开发环境下，css按照style里引入，而在生产环境下是用link引入的。经查阅后才发现MiniCssExtractPlugin这个插件在开发环境下热重载会有问题，所以默认在生产环境下才开启。这里也发现了使用vue-cli确实方便了很多，但是也有很多东西没有明显的配置文件，并不清楚内部如何配置的，后面也是自己都实现了一遍，才大致了解。 继续说懒加载，如此操作产生一个问题，每一个懒加载的组件都会被分成单独的chunk，发现其单独的js和css的chunk里都有重复引入的部分，如下图所示。也就是说进入后台的三个页面，会重复加载其共用的组件。这里经过查阅发现webpack4的SplitChunksPlugin插件默认最下30k才会单独打包。 在最开始，我并不理解webpack的默认策略为什么要这样制定，重复引入组件按道理讲肯定是造成了一些损耗。但其实少考虑了一点，按目前所作的方法，将懒加载的组件单独chunk，但其实每一个chunk才不到8k，甚至有的1k，2k这样子。那么我们为了不重复引入这2k，3k的组件而将其单独抽离出来一个chunk-common，是会额外增加一次http请求的，这样其实未必更优。 其实关于优化，我认为是没有最优的方法的，只有根据业务和需求的不同，尽可能地采取最合适或者说最能适应大部分用户的方案。 在思考代码分离方案时候，首先第三方引入的依赖可以单独打成一个chunk，比如vue,vuex等等这些，这些几乎每个组件都要使用，将其和自己写的业务组件打成一个包很不合理。然后就是引用频率较高的组件或者文件可以单独打成一个chunk，但是还要根据其包的大小具体考虑是否需要单独打包。然后就是一些懒加载引入的单独业务代码了。这里有一篇文章，觉得整理的很好，看后也有很多收获-&gt;链接 我上面把包拆分的太颗粒化了，其实未必比都打到一个包里更优，因为后台页面的大小其实并没有很大。那么后面我将尝试，将多个chunk适当合并，即减少首屏加载，也同样减少过多chunk造成的不必要的http请求。","link":"/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%BC%98%E5%8C%96/"},{"title":"Git分支相关","text":"git分支在多人协作开发里非常重要，之前没有这方面的需求，所以对这方面了解不多。公司实习多人协作开发，需要这部分的掌握，就重新整理了一下。 git分支一般远程仓库有多个分支，master为主分支，应该是非常稳定的，也就是仅用来发布新版本，一般开发都在其它分支进行，当稳定后合并到master分支下，如果出现问题，及时回滚。 多人协作中，每个人都在dev分支上提交，每个人都应该创建自己的分支，然后往dev分支上合并。 实际开发假设，远程仓库有master分支和dev分支，当我们git clone后，将分支切换到dev分支，然后进行开发，当然此处也可以再新加一个分支，当该功能做完后，再合并到dev分支，最后没问题的情况下合并到master分支。其它修bug或者新增一个功能的时候，也都可以新增一个分支，完成后合并，最后将分支删除。（当然，此处说的可能和实际开发还会有些出入，因为还没有真正在公司开发中尝试。如果后面有别的理解后，会再做做修改）。 分支合并两种方式： merge rebase 首先merge便于理解，merge会把两分支的最新快照以及二者共同祖先进行三方合并，结果是产生一个新的快照。 而rebase命令能将提交到某一分支上的所有修改都移至另一分支上，其最直接的结果就是能确保在向远程分支推送时，能保持提交历史的整洁，即使用git log --graph查看分支提交历史时，是一条直线，更加简洁。 相关命令整理提交文件到git仓库 12git add &lt;file&gt; #将工作区文件提交到暂存区git commit -m &lt;message&gt; #将暂存区提交到分支 远程仓库 123git remote #查看远程仓库信息git remote -v #查看更加详细的远程仓库信息git push orgin &lt;分支&gt; #推送到远程仓库分支 分支相关 12345678git branch #查看分支git branch &lt;name&gt; #创建分支git checkout &lt;name&gt; #切换分支git checkout -b &lt;name&gt; #创建+切换分支git merge &lt;name&gt; #将目标分支合并到当前分支git branch -d &lt;name&gt; #删除目标分支git rebase &lt;name&gt; 解决冲突 当提交到远程仓库时，目标与当前不一致（即可能别人在这条分支上提交后），就会产生冲突。需要先在本地把冲突解决，然后提交。 123git pull #将最新的提交从orgin分支上抓取下来git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt; #本地分支与远程分支链接# 然后在本地合并，然后git add，git commit 提交","link":"/git%E5%88%86%E6%94%AF%E7%9B%B8%E5%85%B3/"},{"title":"vue-cli源码学习1.x","text":"说起vue-cli源码的阅读，主要源于公司实习时候，对公司的前端脚手架比较感兴趣，然后就开始看了看，但是看的不是很明白。就准备先看看比较熟悉的vue-cli，而且vue-cli使用人数比较多，也有一些源码分析的文章，有助于代码的理解。 但其实看一遍别人的文章，感觉只是稍微明白了一点。于是，本着学习cli工具的开发思路，因此，从master分支的第一个提交开始看起，准备梳理一下整个cli工具的开发流程，以及作者的一些思考。 这篇文章将主要分析vue-cli 1.x版本的一些原理。 整体思路 bin/ 目录下面放命令文件，比如vue，vue-init，vue-list，注意这里没有加js后缀 lib/ 目录下面放一些公共的方法 其实vue-cli最初只提供了两种命令，分别是vue init初始化项目，以及vue list查看模板列表。命令行的控制则主要是引入commander包来控制。这里选项交互暂时没用到inquirer包，后面版本会用到。 bin目录写到package.json文件中作用是可直接命令行启动，即npm i -g后可直接使用vue init &lt;package-name&gt; &lt;project-name&gt;形式。 同时，为了方便调试，可以直接在目录下面npm link到全局，这样改动后可以直接看到效果。原理即创建软连接，使用npm unlink即可取消。 脚本文件调用主文件vue如何根据用户输入选择执行不同脚本文件？ 最开始使用child_process.spawn(脚本路径，参数)直接执行，如下 12345// 这里执行子进程，根据命令行输入，执行不同bin下文件// 注意这里有一个执行权限问题，chmod 755 file// 但是不太清楚如果发布以后，npm下载之后，是否可执行，如果权限是不可执行，那其它用户下载后又该如何解决？已解决，用commander特性spawn(bin, args, { stdio: 'inherit' }) .on('close', process.exit.bind(process)) 后来的提交直接使用了commander特性，如下所示，command加入第二个参数，就可以在目录下面寻找vue-init与vue-list文件执行，省了一大段调用nodeAPI获取输入参数，选择脚本路径与参数的代码。 123456require('commander') .version(require('../package').version) .usage('&lt;command&gt; [options]') .command('init', 'generate a new project from a template') .command('list', 'list available official templates') .parse(process.argv) vue initvue init的思路很简单，就是预先写好一个模板，放到远程仓库中。然后当使用vue init选择不同模板构建时，则下载不同的模板。先将模板下载到/tmp下，然后再将其generate到项目位置，而不是直接将其下载到目标位置。 一些预设选项是通过下载下来的模板中meta.json中的选项来交互。版本目前暂时还不能init成功，据我推测是代码比较老，和template不太匹配的缘故。比较有意思的是作者最初使用的Khaos包来generate到目标位置，可能作者觉得这个太麻烦了，重新封装了一下这个包叫khaos-patched，一行代码就能实现功能。也有些借鉴意义。 这里有一个用法比较独特（之前没见过） 12345// 举例：如果返回-1，则 ~-1 为 0， 也就是说没有找到，即为false，加上！，即为 true，既没有找到就进入// 如果返回其他值，则 ~number为 非0，即找到true，加上！即为falseif (!~template.indexOf('/')) { template = 'vuejs-templates/' + template} 算的上奇淫巧技吧，但是有意思的事，作者在后面的版本中修改了，变成了如下，可能是觉得可读性不太好？ 1234var hasSlash = template.indexOf('/') &gt; -1if (!hasSlash) { template = 'vuejs-templates/' + template} vue listvue list实现思路很简单，直接发请求获取一些模板列表，显示出来。这里就不多做解释了。 更新情况2.0.x依赖完成功能 使用 inquirer 和 metalsmith 代替 Khaos 和 prompt-for 添加lint和test,以及重构项目,将Metalsmith所用插件方法单独抽离,放进lib 使用ora代替lib/spinner.js 添加vue-cli版本检查 1.4.x完成功能 添加lib/spinner.js下载动画 1.3.x依赖 prompt-for-patched: 命令行问题及选择 完成功能 添加-c参数，可直接下载任意git仓库 添加没有指定project-name时，可将当前目录初始化功能 1.2.x依赖 download-git-repo: 下载github仓库 完成功能 使用download-git-repo替换download-github-repo 1.1.x依赖 khaos-patched: yyx自己基于khaos写的 完成功能 将khaos替换为khaos-patched 添加lib/git-user.js获取作者 1.0.x依赖 commander: 命令行交互 chalk: 命令行高亮 cross-spawn: Node子进程 download-github-repo: 下载github上仓库 khaos: 生成项目 rimraf: rm -rf uid: 生成一串随机数 完成功能 构建项目主框架，完成vue init功能和vue list功能，使用子进程切换执行脚本 抽离lig/logger.js信息输出 使用commander的方法,删除大量vue脚本代码 增加目录下是否已有模板判断 总结当然，目前只是看了最初的几次提交，1.x版本还有好多次提交，代码结构比较简单，后面会愈发复杂。同时上述原理只是1.x的前期版本，不包括2.x以及3.x版本。特别是3.x有了较大的改进。 ———————-2019.8.3—————————- 1.x版本已经看完了，2.x版本也已经看完了。看完后觉得还是非常清晰地，当然和3.x版本相比，之前的版本还是有比较大的去别的。1.x和2.x版本总体上来讲，还是从远程仓库下载模板，可配置性虽然有但还是不够灵活，而且扩展性非常不好。3.x版本的最大特点就是插件式引入，而且开发者也可以直接开发自己的插件，更加灵活。","link":"/vue-cli%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A01-x/"},{"title":"vue-cli源码学习2.x","text":"前言vue-cli的2.9.6版本看完之后，对cli脚手架的整个原理才有了一个比较清晰的认识，其可配置性主要体现在三个方面，即可配置性问答，可配置性文件，可配置性文件内容。文章也将主要整理这三个部分是如何实现的。 流程介绍 vue文件开始，根据输入vue init/list 执行不同文件 选择vue init，进入执行 vue-init 根据isLocalPath()判断是 本地模板 还是 官方模板 如果是当前路径的template，则调用getTemplatePath()确保其是绝对路径，并进入 generate() 如果是官方模板，则需要检查版本（向远程发送请求，获取cli当前latest的版本和本地安装的版本） 根据选择获取 模板路径，生成路径，项目名，进入 downloadAndGenerate()，然后download()之后进入generate() 进入generate() 首先通过getOptions()获取模板下meta.js/meta.json的配置（其中包含了不同模板的提问），getOptions()里面设置项目名，以及设置包名验证，然后调用getGitUser()获取git配置的用户名，然后设置作者 然后使用Metalsmith，先调用meta.js的metalsmith.before的方法，其目的是合并一些参数，比如合并isNotTest，然后在test测试的时候，跳过问答部分 metalsmith可传入插件（函数）产生结果，其实和gulp的pipe管道很像 先调用 askQuestions() 获取模板中meta.js中的prompt数据，使用inquirer包来控制问答交互，并将用户输入答案存入metalsmith.metadata()全局变量中，以便后面使用 然后调用 filterFiles() 获取模板中meta.js中的filters数据，然后根据上一步用户输入，来删去模板中用户不需要的文件。其实现方式是：遍历模板filters，然后内层遍历所有模板文件，如果符合某条件，则将该文件删去 调用 renderTemplateFiles() 跳过一些文件生成以及根据Handlebars.registerHelper的定义，替换模板中的部分，使其内容可配置。其中实现方法是：使用handlebars，模板渲染的时候将其中的部分替换，首先定义一些条件，然后在模板相应位置写条件（和ejs模板渲染引擎比较像），然后根据一些选项来控制具体内容是否需要，最后生成最终文件 vue list的实现则和vue 1.x版本相同，向远程仓库发起请求，获取对应模板列表，然后输出出来 细节分析启动123456789program .version(require('../package').version) .usage('&lt;command&gt; [options]') .command('init', 'generate a new project from a template') .command('list', 'list available official templates') .command('build', 'prototype a new project') .command('create', '(for v3 warning only)')program.parse(process.argv) 入口文件很简单，使用commonder的command方法，给第二个描述参数，则用户输入命令时执行不同的文件 核心generate()npm包先看一下引入的npm包，注释里简单介绍一下功能 12345678910111213// 命令行界面高亮const chalk = require('chalk')// 传入方法，生成目标文件const Metalsmith = require('metalsmith')// 构建语义模板，可以看到下载的模板里面有 if_eq 等字样const Handlebars = require('handlebars')// 异步执行const async = require('async')// 模板引擎合并库，直接使用了handlebarsconst render = require('consolidate').handlebars.renderconst path = require('path')// 匹配const multimatch = require('multimatch') generate()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253module.exports = function generate (name, src, dest, done) { const opts = getOptions(name, src) // console.log(&quot;opts:&quot;, opts) console.log(&quot;src:&quot;, src) const metalsmith = Metalsmith(path.join(src, 'template')) const data = Object.assign(metalsmith.metadata(), { destDirName: name, inPlace: dest === process.cwd(), noEscape: true }) // console.log(&quot;metalsmith1:&quot;, metalsmith) opts.helpers &amp;&amp; Object.keys(opts.helpers).map(key =&gt; { Handlebars.registerHelper(key, opts.helpers[key]) }) const helpers = { chalk, logger } if (opts.metalsmith &amp;&amp; typeof opts.metalsmith.before === 'function') { // 调用meta.js的metalsmith.before的方法，并传入metalsmith，meta.js的配置，以及高亮和打印输出 // 做的工作是合并一个isnotTest，目测应该是做一个不是test的标识【待验证】 opts.metalsmith.before(metalsmith, opts, helpers) } // console.log(&quot;metalsmith2:&quot;, metalsmith) // 询问问题， // 将不需要的文件过滤掉 // 跳过一些文件生成以及根据Handlebars.registerHelper的定义，替换模板中的部分，使其内容可配置 metalsmith.use(askQuestions(opts.prompts)) .use(filterFiles(opts.filters)) .use(renderTemplateFiles(opts.skipInterpolation)) if (typeof opts.metalsmith === 'function') { opts.metalsmith(metalsmith, opts, helpers) } else if (opts.metalsmith &amp;&amp; typeof opts.metalsmith.after === 'function') { opts.metalsmith.after(metalsmith, opts, helpers) } metalsmith.clean(false) .source('.') // start from template root instead of `./src` which is Metalsmith's default for `source` .destination(dest) .build((err, files) =&gt; { done(err) if (typeof opts.complete === 'function') { const helpers = { chalk, logger, files } // 执行meta.js中的complete方法 // webpack模板中则是排序依赖包，安装依赖包，输出相应信息 opts.complete(data, helpers) } else { logMessage(opts.completeMessage, data) } }) return data} 代码很长，我们分开来讲，细节就不再多说，主要说核心实现。 生成文件前期1234567891011121314151617181920const opts = getOptions(name, src)// console.log(&quot;opts:&quot;, opts)console.log(&quot;src:&quot;, src)const metalsmith = Metalsmith(path.join(src, 'template'))const data = Object.assign(metalsmith.metadata(), { destDirName: name, inPlace: dest === process.cwd(), noEscape: true})// console.log(&quot;metalsmith1:&quot;, metalsmith)opts.helpers &amp;&amp; Object.keys(opts.helpers).map(key =&gt; { Handlebars.registerHelper(key, opts.helpers[key])})const helpers = { chalk, logger }if (opts.metalsmith &amp;&amp; typeof opts.metalsmith.before === 'function') { // 调用meta.js的metalsmith.before的方法，并传入metalsmith，meta.js的配置，以及高亮和打印输出 // 做的工作是合并一个isnotTest，目测应该是做一个不是test的标识【待验证】 opts.metalsmith.before(metalsmith, opts, helpers)} 这一部分做的事情主要是读取模板下meta.js文件中的配置信息，其中包含的信息有 metalsmith全局变量（比如isNotTest，应该就是在test时候跳过问答部分），通过opts.metalsmith.before(metalsmith, opts, helpers)合并进来 helpers即handlesbar的渲染模板，通过Handlebars.registerHelper(key, opts.helpers[key])合并进来 prompts即inquire需要使用的模板配置问题（后面讲） filters即根据回答，讲不需要文件删除的部分（后面讲） complete生成文件时调用（后面讲） 生成文件中期123456// 询问问题，// 将不需要的文件过滤掉// 跳过一些文件生成以及根据Handlebars.registerHelper的定义，替换模板中的部分，使其内容可配置metalsmith.use(askQuestions(opts.prompts)) .use(filterFiles(opts.filters)) .use(renderTemplateFiles(opts.skipInterpolation)) 这一部分做了三件事，询问问题，过滤文件，模板渲染文件，其实现方式是 askQuestions就不详细说了，比较简单 filterFiles，通过遍历filters规则，然后内层遍历模板下所有文件，如果和filters的value相匹配，则delete掉文件 123456789101112131415const fileNames = Object.keys(files)// console.log(&quot;fileNames:&quot;, fileNames)Object.keys(filters).forEach(glob =&gt; { // 遍历filters规则 fileNames.forEach(file =&gt; { // 遍历生成的所有文件，dot允许匹配.开头的文件 if (match(file, glob, { dot: true })) { // condition是filters的value const condition = filters[glob] if (!evaluate(condition, data)) { delete files[file] } } })}) renderTemplateFiles，遍历每个文件，异步处理其中的内容，将所有可配置部分根据注册的模板以及回答，来选择文件内容如何生成。可以看下面的handlebars介绍 123456789101112131415161718192021222324252627282930return (files, metalsmith, done) =&gt; { const keys = Object.keys(files) const metalsmithMetadata = metalsmith.metadata() async.each(keys, (file, next) =&gt; { // skipping files with skipInterpolation option if (skipInterpolation &amp;&amp; multimatch([file], skipInterpolation, { dot: true }).length) { return next() } // str是文件内容 const str = files[file].contents.toString() console.log(&quot;str:&quot;, str) // do not attempt to render files that do not have mustaches if (!/{{([^{}]+)}}/g.test(str)) { return next() } // 使用handlebars，模板渲染的时候将其中的部分替换 // 比如：如果选择使用router，那么，模板中的main.js文件中就会渲染出import router部分 // {{#router}} // import router from './router' // {{/router}} render(str, metalsmithMetadata, (err, res) =&gt; { if (err) { err.message = `[${file}] ${err.message}` return next(err) } files[file].contents = new Buffer(res) next() }) }, done)} handlebars123456789101112// register handlebars helperHandlebars.registerHelper('if_eq', function (a, b, opts) { return a === b ? opts.fn(this) : opts.inverse(this)})Handlebars.registerHelper('unless_eq', function (a, b, opts) { return a === b ? opts.inverse(this) : opts.fn(this)}) 注册模板渲染，作用是实现模板文件内容的可配置。举个例子，如果选择时，选择引入vue-router，那么这个时候，main.js肯定要引入，这个时候就可以根据handlebars注册的模板进行有选择性渲染。 当然上面的注册并没有注册router的，因为不同模板不一样，并非每一个模板都需要router，那么是如何实现可配置性呢？就是根据用户选择，来选择是否需要渲染。 这里贴一下webpack的模板就明白了 123456789{{#if_eq build &quot;standalone&quot;}}// The Vue build version to load with the `import` command// (runtime-only or standalone) has been set in webpack.base.conf with an alias.{{/if_eq}}import Vue from 'vue'import App from './App'{{#router}}import router from './router'{{/router}} 生成文件后期1234567891011121314metalsmith.clean(false) .source('.') // start from template root instead of `./src` which is Metalsmith's default for `source` .destination(dest) .build((err, files) =&gt; { done(err) if (typeof opts.complete === 'function') { const helpers = { chalk, logger, files } // 执行meta.js中的complete方法 // webpack模板中则是排序依赖包，安装依赖包，输出相应信息 opts.complete(data, helpers) } else { logMessage(opts.completeMessage, data) } }) 这一部分就是生成文件的部分了，在经过了前面三个函数的处理之后，此时的文件已经基本成型，内容也已经是配置后的了，这一部分还会调用一下meta.js中的complete部分，比如这里的complete就是先给依赖排序，然后执行npm install 12345678910111213141516171819202122complete: function(data, { chalk }) { const green = chalk.green sortDependencies(data, green) const cwd = path.join(process.cwd(), data.inPlace ? '' : data.destDirName) if (data.autoInstall) { installDependencies(cwd, data.autoInstall, green) .then(() =&gt; { return runLintFix(cwd, data, green) }) .then(() =&gt; { printMessage(data, green) }) .catch(e =&gt; { console.log(chalk.red('Error:'), e) }) } else { printMessage(data, chalk) }} 总结vue cli 2.9.6是 2.x的最后一个版本，其核心内容就是generater()的部分，其包含了三大核心内容，可配置性问答，可配置性文件，可配置性文件内容。正是由于此，才另vue cli 2.x和1.x相比，更加的灵活。 但是虽然如此，2.x和1.x还是都没有逃出其核心原理是直接下载远程模板，其配置性也都是在模板的基础上进行的。还是不够灵活，那vue 3.x则使用插件式，令模板更加灵活（当然这里vue cli 3.x还没有看完，说的不一定对，看完之后会回来修改的）","link":"/vue-cli%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A02-x/"},{"title":"浏览器重绘和requestAnimationFrame","text":"又是很久没写文章了，简单总结一下从去年八月到现在将近一年的事吧，去年八月那会儿当时在学脚手架相关的部分，当时实习了一个月就离职准备秋招了，然后在秋招也拿到了满意的offer了。然后就是大四寒假了，写了一个外卖平台的小程序，差不多写了快两个月吧，中间也确实遇到一些比较有意思的问题，后面会简单整理一下遇到的问题。然后就是毕业设计和毕业论文了。差不多项目上主要做了这些事情吧，小程序和毕业设计也算是都有所收获吧。 然后就是回到本文中的标题了，因为被分到了小游戏的组，入职后可能会做一些工具上的开发。因为这方面实在是了解不多，也是趁着论文写完赶紧先学习一下相关的部分吧。 思考其实目前根据个人粗浅的理解，小游戏就是不同帧数绘制不同的物体，中间可能会有一些用户的交互来改变这些物体的位置等等。 那么虽然微信小游戏和浏览器的环境不同，但是也有相似之处，因为了解不多，这里暂且先归为一类。那么图像的绘制必然要涉及到浏览器的绘制部分。 其实经历了春招秋招，大家对浏览器的工作原理比如语法分析、构建DOM、重绘重排等等流程肯定都比较了解了。这里就不再多说，但是目前又产生了一些疑问。首先requestAnimationFrame的使用就是在浏览器绘制之前会产生回调，因为浏览器的一些策略等等，大概是 1000ms / 60 近似等于 16.7ms 的频率绘制。 但是这里每经过 16.7ms 浏览器一定会绘制吗？这里的浏览器绘制和重绘是一个概念吗？ 如何捕捉浏览器何时进行绘制 或者 何时进行重绘？使用 requestAnimationFrame来捕捉？ 首先，必须要知道，浏览器有自己的一些优化策略，比如连续的更改DOM的颜色，按照对个人对重绘的理解，更改颜色是会触发重绘的，更改DOM位置等会触发回流，回流必然重绘。但是假如连续的更改两次颜色（css要指定transition动画），比如 12document.getElementById('test').style.backgroundColor = 'red'document.getElementById('test').style.backgroundColor = 'blue' 诸如上面代码其实并不会看到颜色的变化，即只能看到蓝色，而不能看到红色，那么明显浏览器对这部分在一定时间会收集所有操作，然后一次改变，我暂时认为这个时间是浏览器绘制的频率时间即16.7ms为界。 然后根据对回流重绘的了解，诸如获取布局尺寸等信息的时候，为了保证准确性会强制触发回流重绘，比如offsetTop、getComputedStyle()等等相关资料。 因此我们做如下改动 123document.getElementById('test').style.backgroundColor = 'red'console.log(&quot;offsetTop:&quot;, document.getElementById('test').offsetTop)document.getElementById('test').style.backgroundColor = 'blue' 可以发现颜色发生了渐变，那么可以得出会触发浏览器重新绘制，但是问题来了，我如何去得出浏览器在执行offsetTop的时候发生了重新绘制？根据我目前所掌握的，我发现似乎只有requestAnimationFrame有可能能捕捉这个过程，按照我原本的理解，由于触发重新绘制，所以这个时候会触发requestAnimationFrame的回调，因此我写下了下面的代码 12345678910111213141516171819202122let number = 1let date = new Date().getTime()window.requestAnimationFrame(count)document.getElementById('test').style.backgroundColor = 'red';console.log(&quot;offsetTop:&quot;, document.getElementById('test').offsetTop)// for (let i = 0; i &lt; 10000; i++) {// console.log(&quot;offsetTop:&quot;, document.getElementById('test').offsetTop)// }document.getElementById('test').style.backgroundColor = 'blue';function count() { console.log(&quot;offsetTop:&quot;, document.getElementById('test').offsetTop) let now = new Date().getTime() let res = now - date date = now console.log(&quot;res:&quot;, res) number++ window.requestAnimationFrame(count)} 按照我原先的想法，在count函数中立即触发offsetTop来立即刷新浏览器绘制，此时输出的res数值一定会有介于0-16.7ms之间的。但是在写下这篇文章的过程中，我又突然想到，16.7ms是浏览器基于硬件限制做出的界定，因此可以说16.7ms是最理想的刷新情况，因此应该是不可能出现小于16.7ms的情况。 那么问题来了，offsetTop触发回流重绘如何体现？ 将中间注释掉的代码加上后，会发现第一次requestAnimationFrame回调大概发生在600ms左右，因此说明浏览器绘制延迟了很久。 在吃饭的时候，我发现我其实想清楚了一个问题，那就是浏览器重绘(repaint)和浏览器的绘制(paint)似乎是两个概念。借用一下浏览器渲染原理文中的分析 可以看出按照文中的分析，重绘是一个整体的过程，而按照个人的理解requestAnimationFrame所指的浏览器刷新频率是一个固定频率刷新的东西，这里我认为由于个人知识的局限，暂时没有必要将其的概念分析的很清晰，目前需要清楚的地方： 浏览器重绘是一个过程，涉及到计算样式、排版计算、绘制、渲染层合并等流程的整体过程 requestAnimationFrame是一个浏览器根据硬件限制所做出的刷新频率回调（虽然似乎并不一定会固定回调，比如上文中代码的测试） 暂时清楚这两个点目前来讲已经可以，具体的区别与联系目前看别人的技术文章似乎已经没有办法回答我的个人疑惑，只等后面这方面技术积累更多的时候，有更加多的想法的时候再来看这个问题，也许能有不同的见解。","link":"/%E6%B5%8F%E8%A7%88%E5%99%A8%E9%87%8D%E7%BB%98%E5%92%8Crequestanimationframe/"},{"title":"DOM操作","text":"最近虽然一直在做一些小任务，但是发现对HTML元素的操作并不十分清楚，完全是为了实现而实现，代码质量太低，于是准备将DOM梳理一下。 HTML DOM节点树 简单讲，通过HTML DOM，树中的所有节点都可以通过JavaScript的代码进行访问，即对HTML的元素进行修改、添加、删除等操作。此本分务必熟练掌握。 为了便于理解关于节点问题，我从W3c引一个例子，如下代码段： 123456789&lt;html&gt; &lt;head&gt; &lt;title&gt;DOM 教程&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;DOM 第一课&lt;/h1&gt; &lt;p&gt;Hello world!&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 从上面代码中 &lt;head&gt; 和 &lt;body&gt; 的父节点是 &lt;html&gt; 节点 文本节点 “Hello world!” 的父节点是 &lt;p&gt; 节点 &lt;title&gt; 节点也拥有一个子节点：文本节点 “DOM 教程” &lt;h1&gt; 和 &lt;p&gt; 节点是同胞节点，同时也是 &lt;body&gt; 的子节点并且： &lt;head&gt; 元素是 &lt;html&gt; 元素的首个子节点 &lt;body&gt; 元素是 &lt;html&gt; 元素的最后一个子节点 （顺便说一句，由于Markdown语法是最终变成HTML代码，所以尖括号会无法显示，于是可用’&amp;lt加一个;’代替前尖括号，用’&amp;gt加一个;’代替后尖括号。） HTML DOM常用方法及对象一些常用的 HTML DOM 方法： getElementById(id) - 获取带有指定 id 的节点（元素） appendChild(node) - 插入新的子节点（元素） removeChild(node) - 删除子节点（元素） 一些常用的 HTML DOM 属性： innerHTML - 节点（元素）的文本值 parentNode - 节点（元素）的父节点 childNodes - 节点（元素）的子节点 attributes - 节点（元素）的属性节点 以上内容基本为概念，下面开始测试。 一、元素内容的获取本块测试将测试innerHTML、nodeValue属性对元素内容的获取，以及nodeName及nodeType的作用测试。 将要操作的HTML代码如下： 1234&lt;div id=&quot;div&quot;&gt; &lt;h1 id=&quot;h1&quot;&gt;Hello&lt;/h1&gt; &lt;p id=&quot;p&quot;&gt;Word&lt;/p&gt;&lt;/div&gt; 1、innerHTML获取目标内容：12var text1 = document.getElementById('h1').innerHTML;document.write(text1); 可以看到innerHTML直接获取了目标内容，虽然此时处在文本节点的父节点位置。 2、nodeValue获取：12var text2 = document.getElementById('h1');document.write(text2.firstChild.nodeValue); 需要注意的是当获取id之后此时处于h1元素位置处，innerHTML可以直接获取内容。而nodeValue则需先用firstChild等获取目标文本节点，然后用nodeValue获取内容。 ** 补充nodeName作用 **nodeName 属性规定节点的名称。 元素节点的 nodeName 与标签名相同 属性节点的 nodeName 与属性名相同 文本节点的 nodeName 始终是 #text ** 补充nodeType作用 **nodeType 属性返回节点的类型。nodeType 是只读的。 二、元素的访问访问这部分主要测试getElementsByTagName() 方法、getElementsByClassName() 方法这两个。 将要操作的HTML代码如下： 1234567&lt;p id=&quot;p1&quot; class=&quot;x&quot;&gt;这句为div外面第一个p&lt;/p&gt;&lt;p &gt;这句为div外面第二个p&lt;/p&gt;&lt;div id=&quot;div&quot; class=&quot;x&quot;&gt; &lt;h1 id=&quot;h1&quot; class=&quot;x&quot;&gt;Hello&lt;/h1&gt; &lt;p id=&quot;p2&quot; class=&quot;x&quot;&gt;这句为div里面第一个p&lt;/p&gt; &lt;p id=&quot;p3&quot;&gt;这句为div里面第二个p&lt;/p&gt;&lt;/div&gt; 1、getElementsByTagName方法作用：getElementsByTagName() 返回带有指定标签名的所有元素。 1234var t1 = document.getElementsByTagName('p');document.write(t1[0].innerHTML);document.write(t1[2].innerHTML);document.write('&lt;br&gt;'); 上例输出为：这句为div外面第一个p这句为div里面第一个p 1234//当已经用getElementById获取时var t2 = document.getElementById('div').getElementsByTagName('p');document.write(t2[0].innerHTML);document.write('&lt;br&gt;'); 输出为：这句为div里面第一个p 从上面两例可以看出当没有限定时，获取到的元素为所有部分，但是当已经限定在id为div的标签时，此时则只会获取到标签内的部分。 2、getElementsByClassName方法如果希望查找带有相同类名的所有 HTML 元素，请使用这个方法。注意该方法与IE 5,6,7,8不兼容 12345var t3 = document.getElementsByClassName('x');document.write(t3[0].innerHTML);//当获取到整块div时，innerHTML会将整个内容获取document.write(t3[1].innerHTML); 注意浏览器的兼容性，尽量少用该方法，或直接用相应代码兼容IE低版本。 三、元素的修改这部分内容并不复杂，因此把代码贴上，以便查看即可。 123456&lt;p id=&quot;p1&quot;&gt;Hello&lt;/p&gt;&lt;script type=&quot;text/javascript&quot;&gt; //元素修改 document.getElementById('p1').innerHTML = &quot;World&quot;; document.getElementById('p1').style.color = 'blue';&lt;/script&gt; 上面的操作即修改内容，以及修改CSS样式。 四、元素的添加与删除元素内容的添加与删除是DOM操作的核心，这部分较为重要，综合运用了以上三部分内容。 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p id=&quot;p1&quot;&gt;Hello&lt;/p&gt; &lt;div id=&quot;a&quot;&gt; &lt;p id=&quot;p2&quot;&gt;第一行&lt;/p&gt; &lt;p id=&quot;p3&quot;&gt;第二行&lt;/p&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; //元素修改 document.getElementById('p1').innerHTML = &quot;World&quot;; document.getElementById('p1').style.color = 'blue'; //appendChild插入 var node = document.createElement('p'); var textNode = document.createTextNode(&quot;第三行&quot;); node.appendChild(textNode); var element = document.getElementById('a'); element.appendChild(node); //使用insertBefore var new_node = document.createElement('p'); var new_textNode = document.createTextNode('第零行'); new_node.appendChild(new_textNode); var child1 = document.getElementById('p2'); element.insertBefore(new_node,child1); //removeChild删除 var child2 = document.getElementById('p2'); element.removeChild(child2); //使用parentNode查找其父元素 var child3 = document.getElementById('p3'); child3.parentNode.removeChild(child3); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; appendChild() 作为父元素最后一个子元素插入 insertBefore() 插入想要插入元素之前 removeChild() 删除相应元素（需先获取其父元素） parentNode() 查找其父元素（可应用于上一方法） 说到查找元素，这里还要比较一下childNodes和children的区别，两者都是获取父元素的子元素，但是具体实现功能还是不太一样。测试如下： 12345678910111213&lt;p id=&quot;p1&quot;&gt;Hello world!&lt;/p&gt;&lt;div id=&quot;parent&quot;&gt; &lt;p&gt;第一行&lt;/p&gt; &lt;p&gt;第二行&lt;/p&gt; &lt;p&gt;第三行&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var p = document.getElementById('parent'); document.write(p.childNodes[0].nodeName+&quot;&lt;br&gt;&quot;); document.write(p.children[0].nodeName); p.childNodes[3].innerHTML = &quot;新行&quot;;&lt;/script&gt; 输出结果为 可以看到childNodes[0]所指向的元素是div中的文本节点，而children[0]则指向的是div中的第一个p节点，因此可以看出childNodes更加的细致，而children更加的好用，而且便于理解。 五、对事件作出反应本部分简要提一下主要内容 onclick 用户点击完成时触发 onload 用户进入页面时触发 onchange 当用户改变输入字段时触发（一般用于input标签） onmouseover 鼠标指针移动到元素时触发 onmouseout 鼠标指针离开元素时触发 onmousedown 鼠标按钮点击时触发 onmouseup 鼠标按钮被松开时触发 总结DOM操作基本内容大概就这么多，虽然整理了这么多，对这些也有了一个更加清晰的认识，但是离熟练使用还有一段距离，还是要不断的多练习，才能有更大的提高。继续努力。","link":"/dom%E6%93%8D%E4%BD%9C/"},{"title":"虚假的第一篇博客","text":"为什么说是虚假的第一篇博客，因为其实学生时代是写了挺多文章的，数了一下大概30+篇。但是回顾起来","link":"/%E8%99%9A%E5%81%87%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"},{"title":"改造icarus博客主题（一）","text":"修改 config.yml配置相关内容直接看文档即可 https://hexo.io/zh-cn/docs/configuration 永久链接调整文章的url永久链接，可以根据文档自由文章定制url链接 1permalink: ':post_title/'","link":"/%E6%94%B9%E9%80%A0icarus%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"jQuery和原生DOM操作对比","text":"说到这个jQ库，我之前一直搞错一个概念，以为jQ是一个框架，但是查了一些资料后呢，发现它原来是个库。那么它们的区别是什么呢，本质区别在于控制反转。那么通俗点讲，库是一个封装好的集合，控制权在使用者。而框架是一个架构，向用户提供解决方案，控制权在框架。 那么不说那么专业的东西，说点我看完jQ的体会，发现jQ确实会让js编程变得简单很多，特别是Ajax的使用，jQ里面并不复杂，但是若要直接写原生js那是有点麻烦的。虽然这些东西很方便，但是我要说的是，一定不要依赖于库或者框架，前端技术发展很快，框架层出不穷，但是核心的js是不会变的，这些所有东西都是可以用原生js实现的。所以，学这些东西的时候最好再用js尝试实现相应的功能，这样才能游刃有余。 一、jQ获取元素jQ库与js原生代码的比较如下： 可以看到，仅从此处对比，并不能看出jQ的方便，因为毕竟功能太小，此处先引出jQ是如何获取元素的，引用一张来自w3school的图： 即可从图上看出id，class，标签等的获取语法 二、jQ设置内容jQ库与js原生代码的比较如下： 输出结果如下： 此处依然不能体现出jQ的方便之处，还是因为功能并不复杂，但是之后的比较，会发现jQ的方便之处 三、jQ添加删除元素jQ库与js原生代码的比较如下： 输出结果如下： 注意js原生代码部分两种方法的不同，第一种方法是与左侧jQ库写出的效果相同，第二种则是直接创建p标签进行追加文本 从此处其实已经可以看出jQ的方便之处，降低了代码复杂度，使代码更加简洁。 四、jQ功能简介jQ库功能可以说是很强大，把js代码实现某些功能变得简单了很多。jQ几个主要实现的功能包括以下几个方面： 对DOM的操作，比如上面介绍的几种 jQ的动画效果，比如淡入淡出效果、滑动效果 Ajax的功能，使Ajax的写法变得简单 当然功能应该不止这些，这只是我目前所了解的功能的一个概括，其他具体功能可从网上搜索。 五、结语总感觉目前写的这几篇博客内容太水了，技术深度不够，只是一些很基本的内容，没有什么深入的剖析。仅仅是对所学内容一个简单的使用而已，希望能随着技术的提高，逐渐写一些有深度的文章。","link":"/jquery%E5%92%8C%E5%8E%9F%E7%94%9Fdom%E6%93%8D%E4%BD%9C%E5%AF%B9%E6%AF%94/"},{"title":"如何实现一个导航栏","text":"最近在看bootstrap框架，随便看了点之后觉得框架确实方便，但是感觉用框架之后很拘束，而且bootstrap框架也挺大，为了实现某些功能而引入框架，实在有点大材小用，所以我想把一些功能自己复现一下。 个人比较喜欢一些炫酷的东西，所以可能会整理一系列CSS实现的效果的博客，作为第一篇，就以导航栏为内容吧。 胶囊导航栏胶囊导航栏十分常见，基本很多网站都是用这种风格，我本人也比较喜欢这种风格，此篇博客将整理普通效果，带选中状态效果，以及带下拉标签的效果。 一、普通效果导航栏该效果只需HTML和CSS即可实现，废话不多讲直接上代码： 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;胶囊导航栏&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;task02.css&quot;&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;jquery-3.2.1.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#test1&quot;&gt;页一&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#test2&quot;&gt;页二&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#test3&quot;&gt;页三&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#test4&quot;&gt;页四&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#test5&quot;&gt;页五&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243*{ margin: 0; padding: 0;}div{ background-color: #222222; height: 60px;}ul{ text-align: right; /*右对齐*/ padding-right: 40px; /* 下面两行是为了删除inline-block之间的间隙， 第二行为了兼容Chrome， 内容来自张鑫旭博客 */ font-size: 0; -webkit-text-size-adjust:none;}ul li{ display: inline-block; padding: 0 30px; /*不用margin以便li导航项目选中时没有空隙*/ }ul li a{ text-decoration: none; width: 40px; /*防止IE出现问题*/ display: block; /*允许我们使用width*/ text-align: center; line-height: 60px; /*上下居中*/ font-size: 18px; color: #ffffff;}li:hover{ background-color: #484FFD; } 效果： 说一下要注意的几点： 浏览器默认有padding和margin，所以此处要设置一下 li其实也可以使用float，但是浮动是魔鬼这句话我谨记（自张鑫旭博客），所以能不用float我也尽量不用了 尽量指定a的宽度，具体不指定会出现什么问题，目前没发现，但最好指定一下吧 二、选中效果导航栏选中效果不是hover伪类，而是当鼠标选中时，该块会处于被选中状态，此处分享两种方法（不是我想出来的）。 方法一12345678910//方法一：jQ实现选中效果，但是刷新后效果消失$(document).ready(function(){ $(&quot;li&quot;).each(function(index){ $(this).click(function(){ //下一行防止多个选中状态 $(&quot;li&quot;).removeClass(&quot;selectState&quot;); $(&quot;li&quot;).eq(index).addClass(&quot;selectState&quot;); }) })}) 123.selectState{ background-color: #484FFD;} 方法一用each遍历li数组，并将index值作为参数，removeClass是为了防止出现多个选中情况 另外还有一处需要注意的是inline-block产生的间隙问题 解决方法有几种，此处提出一种font-size: 0;,-webkit-text-size-adjust:none;第二处为了兼容Chrome，详情请跳转张鑫旭博客inline-block间隙解决方案 方法一的不足之处很致命，刷新之后效果就会消失，所以一般不采用这种方案。 方法二1234567891011121314151617181920$(document).ready(function(){ var urlCurrent = location.href; //当然此处也可以遍历li标签，只是下面结构要改一下，查找父元素改为子元素即可 $(&quot;a&quot;).each(function(){ //indexOf返回查找到的字符串中首次出现位置，没找到则返回-1，后一句判断不为空 if(urlCurrent.indexOf($(this).attr(&quot;href&quot;)) &gt; -1 &amp;&amp; $(this).attr(&quot;href&quot;) != &quot;&quot;){ $(this).parent().addClass(&quot;selectState&quot;); console.log(&quot;success&quot;); }else{ $(&quot;li&quot;).parent().removeClass(&quot;selectState&quot;); } }) $(&quot;li&quot;).each(function(index){ $(this).click(function(){ //下一行防止多个选中状态 $(&quot;li&quot;).removeClass(&quot;selectState&quot;); $(&quot;li&quot;).eq(index).addClass(&quot;selectState&quot;); }) })}) 方法二在方法一的基础上，加了一个对a标签的遍历（也可以遍历li标签），原理是，使用location.href获取当前页面url，然后对a标签href属性，使用indexOf方法检索，若找到，则返回大于-1的值，此时将样式表加上。此时再用刷新，则依然会被选中。 三、带下拉框式导航栏这个练习代码是看完学校教务处主页的导航栏代码后写的，代码如下： 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;下拉标签导航栏&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;task03.css&quot;&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;jquery-3.2.1.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;navigation&quot;&gt; &lt;div class=&quot;Test1&quot;&gt; &lt;a href=&quot;#test1&quot;&gt;页一&lt;/a&gt; &lt;div class=&quot;panel1&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#t1&quot;&gt;例1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#t2&quot;&gt;例2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#t3&quot;&gt;例3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;Test2&quot;&gt; &lt;a href=&quot;#test2&quot;&gt;页二&lt;/a&gt; &lt;div class=&quot;panel2&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#t4&quot;&gt;例4&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#t5&quot;&gt;例5&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#t6&quot;&gt;例6&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314$(document).ready(function(){ $(&quot;.Test1&quot;).mouseenter(function(){ $(&quot;.panel1&quot;).stop(true,true).slideDown(100); }) $(&quot;.Test1&quot;).mouseleave(function(){ $(&quot;.panel1&quot;).stop(true,true).slideUp(100); }) $(&quot;.Test2&quot;).mouseenter(function(){ $(&quot;.panel2&quot;).stop(true,true).slideDown(100); }) $(&quot;.Test2&quot;).mouseleave(function(){ $(&quot;.panel2&quot;).stop(true,true).slideUp(100); })}) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152*{ margin: 0; padding: 0;}.container{ background-color: #222222; height: 60px;}li{ list-style: none;}.navigation{ float: right; margin-right: 100px}.Test1, .Test2{ float: left; width: 80px;}.Test2 a, .Test1 a{ text-decoration: none; display: block; text-align: center; line-height: 60px; font-size: 18px; color: #ffffff;}.Test1:hover, .Test2:hover{ background-color: #484FFD; }.panel1 , .panel2{ display: none;}.panel1 ul, .panel2 ul{ border: 1px solid #949494; background-color: #ffffff; box-shadow: 3px 3px 5px #ADADAD;}.panel1 ul a, .panel2 ul a{ color: #000000; font-size: 15px;} 效果： 代码实现思路 1、用navigation包裹住导航部分，并声明右浮动，此时脱离文档流，不会影响后面布局 2、每一个大标签声明左浮动，使顺序正确 3、每一个大标签和下拉框中标签同在一个块中，以便下拉框部分能和大标签部分位置相对，也可以声明panel标签来控制下拉框宽度大小 4、使用mouseenter与mouseleave分别控制鼠标移动至目标与离开目标的不同效果 5、使用stop来控制鼠标离开时动画立即完成 6、使用box-shadow来根据不同情况控制阴影效果 7、可以在下拉框上加hover伪类来控制选中效果（该代码没有使用） 8、注意mouseenter和mouseleave控制的元素，要控制字体和下拉框的父元素才能实现鼠标离开字体或下拉框时，下拉框收回 9、fixed和absolute都能使用z-index来控制层数 结语这是CSS实现效果的第一篇，以后陆续将整理其他效果，以便后面的使用。另外，导航栏效果很多，以后如果有机会，将整理其他一些导航栏的效果。","link":"/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AF%BC%E8%88%AA%E6%A0%8F/"},{"title":"实现一个问卷平台","text":"说来惭愧，好久没有更新博客了，大概过了两个多月吧，这两个多月当然并没有出去浪啊，还是在好好的学习代码的。前一段时间和后端合作了两个项目，一个是问卷平台的项目，就是这次将要总结的内容，还有一个是一个个人的博客。这两个项目也算是和后端的两次比较详细的合作，相比上次的微信小程序有了更大的提高。两个项目坐下来感觉技术提高了不少，但是由于赶进度的原因也欠下了很多技术债，寒假时候要好好的补一补了。不过正所谓业务驱动需求，需求驱动技术嘛。 两个项目下来，发现都用原生的代码写真的累，前一段时间每天基本都是代码，没怎么闲过，有很多重复的劳动，原生代码也写了不少，感觉可以进行学习一些框架了。 页面展示界面做的还是很low的，不过也还勉强能看 技术细节这一部分将整理一下在写页面的时候学到的一些新的技术。 首页首页部分其实做的挺丑的，当时时间比较紧，所以并没有进行设计，直接就开始动手写了，这部分都是一些很常见的东西，但是有一块就是一个正反面的翻转效果感觉挺赞的，是从别的网站上看到然后学习了一下写出来的。 从技术上看实现方法就是采用了两个div层，一个显示的是正面，另一个反面使用rotateY(-180deg)来进行一个180度的翻转，显示成反面，然后使用z-index来达到一个遮罩效果，然后就是hover实现一个点击后的效果将正面设置为rotateY(180deg)并将透明度opacity设置成0，反面设置为rotateY(0deg)透明度opacity设置为1，来使转换更加的自然。不过需要注意的是要将position设置为绝对定位或一些其他的方式，不然z-index不会生效。关键代码如下： 12345678910&lt;div class=&quot;developers&quot;&gt; &lt;!-- &lt;img src=&quot;img/xiaoqi.png&quot;&gt; --&gt; &lt;div class=&quot;renpicture&quot;&gt; &lt;div class=&quot;img img1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;img-font&quot;&gt; &lt;p&gt;后端开发&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;developers-font LwolveJ-font&quot;&gt;LwolveJ&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859.developers { width: 33.3%; height: 500px; display: inline-block; vertical-align: top; text-align: center; position: relative;}.renpicture { width: 250px; height: 250px; margin: 0 auto; position: relative; -webkit-perspective: 1000;}.img , .img-font { position: absolute; margin: 0 auto; width: 250px; height: 250px; border-radius: 50%; box-shadow: 0 3px 5px #9E9E9E; -webkit-transition: all 0.5s;}.img { z-index: 5; background-size: 250px 250px;}.img1 { background-image: url(&quot;../img/lijie.jpg&quot;);}.img-font { font-size: 25px; background-color: #1799e5; -webkit-transform: rotateY(-180deg); opacity: 0;}.img-font p { line-height: 250px; color: #FFFFFF;}.renpicture:hover .img{ -webkit-transform:rotateY(180deg); z-index: 5; opacity: 0;}.renpicture:hover .img-font { -webkit-transform: rotateY(0deg); z-index: 10; opacity: 1;} 生成问卷页面这一个页面所涉及到的代码最多，而且也是该项目的重点，需求主要就是右侧的窗口能生成标题、单选题、多选题、简短回答这几个问卷常见的题型，而且右边所添加的选项能即时在右侧展示，并且能删除选项，然后点击生成问卷会在左侧显示出相应的效果。初次之外还有个比较人性化的细节，即右侧的操作框会随着左侧题目的位置而变动。效果大概就是这么多，那么就是一些技术的实现了。 首先是HTML结构，右侧操作框的HTML结构每种题型都写成一块HTML，然后都使用display:none隐藏，然后默认将标题显示为第一个，然后通过js获取下拉框选择的题型来显示相应的格式。然后是CSS部分，这一部分都是一些之前就用过的，所以此处不再整理。本部分将着重整理js部分的代码。 表单切换功能：12345678910111213141516171819202122232425262728293031//===================表单切换=======================var inputTypeSelectBtn = g('input-type-select');var selectTypes = { &quot;title&quot;: g(&quot;title-box&quot;), &quot;radio&quot;: g('radio-box'), &quot;checkbox&quot;: g('checkbox-box'), &quot;text&quot;: g('text-box')}//获取选择valuevar getSelectContent = function(select) { var index = select.selectedIndex; return select.options[index].value;}//初始化value值var selectValue = getSelectContent(inputTypeSelectBtn);var changeType = function(type) { for(var i in selectTypes){ selectTypes[i].style.display = 'none'; } selectTypes[type].style.display = &quot;block&quot;;}//当表单切换时触发inputTypeSelectBtn.onchange = function() { selectValue = getSelectContent(inputTypeSelectBtn); changeType(selectValue);} 该部分思路是当用户点击题型切换时出发onchange然后getSelectContent函数获取改变的值，并返回给selectValue值，然后当作参数传给changeType函数来控制相应表单的显示与隐藏，这里将四种题型的节点都写在了selectTypes对象里面，也同时方便了后面其他功能的实现。 选项的添加与删除功能首先是绑定事件，分别是鼠标点击事件和键盘回车事件 123456789101112131415161718192021222324252627282930313233var addOptionsBtns = { 'radio': selectTypes['radio'].getElementsByClassName('add-btn')[0], 'checkbox': selectTypes['checkbox'].getElementsByClassName('add-btn')[0]}var addOptionsInputs = { 'radio': selectTypes['radio'].getElementsByClassName('add-option')[0], 'checkbox': selectTypes['checkbox'].getElementsByClassName('add-option')[0]}//为按钮绑定事件for(var key in addOptionsBtns) { (function(e) { addOptionsBtns[e].onclick = function() { var value = selectTypes[e].getElementsByClassName('add-option')[0].value; if(value === &quot;&quot;) { return false; } addOption(selectTypes[e], e, value); selectTypes[e].getElementsByClassName('add-option')[0].value = ''; } })(key)}for (var key in addOptionsInputs) { (function(e) { addOptionsInputs[e].addEventListener('keyup', function() { if (event.keyCode === 13) { addOptionsBtns[e].click(); } }); })(key)} 此处for循环里面的function事件采用了(function(e){}(key))来调用，key即function的参数，当js运行到此处的时候将直接调用，里面的两个addOptionsBtns和addOptionsInputs对象分别对应button按钮的点击事件和input输入框的键盘事件，键盘事件实现的逻辑就是调用了点击事件addOptionsBtns[e].click();。 然后是添加选项和删除选项功能 1234567891011121314151617181920212223242526272829303132333435363738394041//======================配置选项添加及删除功能===========var Option = function(type, value, deleteBtn, selfElement) { this.type = type; this.value = value; this.deleteBtn = deleteBtn; this.deleteBtn.self = this; this.selfElement = selfElement; this.selfElement.self = this;}var options = []; //存放所有选项var addOption = function(selectTypes, key, value) { var type = key; var optionsWrap = selectTypes.getElementsByClassName('options-wrap')[0]; var optionWrap = document.createElement('div'); optionWrap.className = 'option-wrap'; optionWrap.innerHTML = '&lt;div class=&quot;delete-mask&quot;&gt;删除&lt;/div&gt; &lt;span class=&quot;option-set&quot;&gt;' + value + '&lt;/span&gt;'; optionsWrap.appendChild(optionWrap); var deleteBtn = optionWrap.getElementsByClassName('delete-mask')[0]; var selfElement = optionWrap; var option = new Option(type, value, deleteBtn, selfElement); options.push(option); deleteBtn.addEventListener('click', function() { deleteOption(deleteBtn); });}var deleteOption = function(btn) { for(var i = 0; i &lt; options.length; i++) { if(options[i] === btn.self) { options.splice(i ,1); break; } } btn.self.selfElement.parentNode.removeChild(btn.self.selfElement); delete btn.self;} 这一部分先是定义了一个Option()函数，并在addOption()中new了一个option对象出来，然后使用push方法依次存入开始定义的options数组里面，此处的new是一个我目前还不完全理解的用法，以及js原型链，这一个项目整理完之后将整理一片关于new和js原型链的文章。 右侧框移动功能12345678910111213141516171819202122232425var formSetBox = g('content-right');var formBox = g('content-body');var moveSetBox = function() { var questionElements = formBox.getElementsByClassName('question-wrap'); var topPosition = formBox.offsetHeight - questionElements[questionElements.length - 1].offsetHeight; startMove(formSetBox, topPosition, 10);}var timer = null;var positionTop = 0;startMove = function(element, target, interval) { clearInterval(timer); timer = setInterval(function() { var speed = (target - element.offsetTop) / 10; speed = speed &gt; 0 ? Math.ceil(speed) : 0; if (element.offsetTop &gt;= target) { clearInterval(timer); } else { positionTop = positionTop + speed; element.style.top = positionTop + 'px'; } }, interval)} moveSetBox()函数用来计算目标位置即target，startMove()函数是核心功能，target-element.offsetTop是计算目标位置和右侧框到顶部的距离只差。然后，此处需要一些数学的计算，计算出speed速度，interval参数是毫秒单位，即每10毫秒的speed，在该函数中即每10毫秒移动speed值的px，可知随着越接近位置，speed越来越小，但是由于ceil()函数的存在，speed不会小于0。 HTMLElement.offsetHeight 是一个只读属性，它返回该元素的像素高度，高度包含该元素的垂直内边距和边框，且是一个整数。 HTMLElement.offsetTop 为只读属性，它返回当前元素相对于其 offsetParent 元素的顶部的距离。 问卷填写页面这部分页面内容较为简单，有一处值得整理的就是页面间传参的一个功能，页面间传参就是说在问卷选择页面选择一个问卷之后会有使用window.location.href来指定url，然后根据参数的不同来获得问卷内容，并渲染出相应的页面。这里是通过地址传值，并使用函数解析地址，获取到参数，然后GET请求获取到问卷内容。 1234567//页面间参数传递函数获取函数var parseURL = function(url) { var url = url.split(&quot;?&quot;)[1]; var res = url.split(&quot;=&quot;)[1]; console.log(res); return res;} 上面代码即获取参数的代码，res即参数。 问卷结果展示页面该部分通过ajax获取相应选择人数数据，然后乘上一定比值，来使图标更加清晰，然后使用js渲染出来即可，建议可以先在html和对应css写上假内容，然后再来写js，之后将html部分注释掉即可。 后记这次项目算得上真正意义的第一个和后端合作开发的项目，之前的微信小程序更多依靠着封装的API勉强完成，很多地方的原理都不太懂。这次通过完全的原生HTML+CSS+JS开发的项目，虽然代码较多，使用很多框架之类的可以有效的简化代码，但是基础还是很重要的，所以这次项目很有必要。","link":"/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%97%AE%E5%8D%B7%E5%B9%B3%E5%8F%B0/"},{"title":"JS对象整理","text":"之前正在整理问卷平台项目，其中整理到了new这一用法，但发现自己其实对JS对象这一部分并不太熟悉，以及原型链究竟是如何不太清楚，所以便有了这一篇博客的整理，整理内容来自JavaScript权威指南。 对象简介JavaScript语言是动态的————可以新增属性也可以删除属性————但他们常用来模拟静态对象以及静态类型语言中的”结构体”。有时它们也用做字符串的集合。 对象创建三种方法对象的创建可以通过三种方法，分别是对象直接量创建，通过new创建，通过Object.create()方法创建。 1.对象直接量1234var book = { &quot;title&quot;: &quot;javascript&quot;, &quot;author&quot;: &quot;张三&quot;} 如上，便是直接创建对象的方法。 2.通过new创建对象1234var o = new Object(); //创建一个空对象var a = new Array(); //创建一个空数组var d = new Date(); //创建一个表示当前事件的Date对象var r = new RegExp(&quot;js&quot;); //创建一个可以进行模式匹配的对象 上面三种都是通过内置构造函数，还有自定义构造函数，比如 直接使用function构造函数，然后下面通过new来定义变量，下面两个分别为带不带参数以及带两个参数的构造 另外，值得一提的是__proto__属性，该属性是用于查询/设置对象的原型，但是似乎并不支持IE和Opera（此处并未测试），所以不建议使用，点开后会发现有一个constructor属性，指代其构造函数，如下图所示，但是此处并未理解透彻，需待以后深入理解。 3.Object.create()方法创建第一个参数是这个对象的原型，第二个可选参数是对对象属性的进一步描述，例如 __proto__是其继承的原型，可以看到第一层__proto__继承的是{x:1,y:2}，然后第二层__proto__继承的是Object原型。 不可变原始值和可变的对象引用原始值（undefined、null、布尔值、数字、字符串），对象（包括数组和函数），原始值是不可更改的，而对象则不同 不可变原始值 可以看到原始值不可更改 可变的对象引用然而对象引用却可变 可以看到当另b=a.p的时候相当于将b指向了a.p，那么这个时候两个变量指向的就是同一个值，这时候为b.x赋值，那么a.p.x同样会被改变，这就是对象引用的可变。那么如果我们不想这样该怎么办呢，可以逐一赋值，比如说 直接对c的属性x进行赋值，这时候就不会将c指向a.p，这时候改变c.x就不会改变a.p.x 对象属性特性 可写，表明是否可以设置该属性的值 可枚举，表明是否可以通过for/in循环返回该属性 可配置，表明是否可以通过删除或修改属性 对象检测属性检测对象里面包含的属性，可使用in、hasOwnProperty、propertyIsEnumerable方法来完成该工作。 in hasOwnPreperty propertyIsEnumerable 三者之间区别in自有属性和继承属性都能返回true，hasOwnPreperty自有属性返回ture，继承属性返回false，propertyIsEnumerable自有属性为可枚举时才返回true，是hasOwnpreperty的增强版 getter和setter由getter和setter属性定义的属性称作“存储器属性”，不同于“数据属性”，当调用getter方法时，返回值就是属性表达式的值，当程序设置一个存取器属性的值时，将调用setter方法，将右侧的值当作参数传入setter。如果属性同时具有getter和setter方法，那么他是一个读/写属性，如果只有getter则是只读。只有setter则是只写，读取数据将返回undefined。 getter和setter的枚举这里假如说定义一个get r()或定义一个set r()，那么这个r也是可枚举的，也就是说可以通过for/in循环来遍历到。 那么修改一下可枚举性 可以看到通过for/in循环并没有循环到属性r，也就是说可以通过设置属性的可枚举性来控制是否由for/in循环到。 继承下的for/in循环同时，可以通过继承来达到for/in循环的遍历效果 可以看到for/in循环循环到了xyr，倘若这时候设置其原型a的某个属性的可枚举型为false，那么也会受到影响。 实例 如上图是一个定义getter和setter的实例，注意，theta只有getter方法，没有setter方法，所以是只读的，下面进行测试 可以看出上图，都获取到了相应的值 对比看出，对r的修改成功了，而对theta的修改并没有成功。 通过getOwnPropertyDescriptor()方法获得属性描述 value: 值 writable: 可写性 enumerable: 可枚举性 configurable: 可配置性 通过definePeoperty()方法修改属性描述可通过该方法修改或直接添加数据属性 上面即通过definePeoperty添加的一个x数据以及修改的属性 总结本来这次想把原型链也顺带整理一下，结果发现这也是一块比较复杂的东西，所以决定详细学习一下类的使用继承方法等内容之后再来详细整理一下类和模块以及原型链的内容。","link":"/js%E5%AF%B9%E8%B1%A1%E6%95%B4%E7%90%86/"},{"title":"模板引擎ejs+gulp的使用","text":"由于接了个项目，项目里面有很多样式重复的页面，或者还有比如说header或者footer这些每个页面几乎都有的模块。如果按照以往的技术，我肯定会选择直接复制粘贴啦，但是这样的最大问题就是，如果页面改动，那么你要逐个页面的去改动才能将整个网站改变，这样费时费力。于是乎，本着需求驱动技术的原则，学习了一下前端模板引擎ejs。当然，除了ejs还有很多模板引擎，但是业务紧急就选择了这么一个语法比较简单技术。为了将ejs本地编译成html，自动化构建工具进入视野，相比于grunt，我又选择了一个相对容易上手的gulp这么个工具。 准备工作此处已默认全局安装gulp工具 本地安装gulp1npm install --save -dev gulp 此处使用cnpm似乎无法安装，暂时未搞清楚原因 本地安装gulp-ejs1npm install --save -dev gulp-ejs 此处--save和-dev自动把模块和版本号添加到package.json中devdependencies部分 项目结构 dist layout.html //gulp-ejs插件生成结果 include footer.html header.html node_modules ……. //一些npm包 gulpfile.js //gulp任务文件 layout.ejs //ejs文件 package-lock.json //配置文件 ejs部分ejs部分的语法比较的少，目前用到的就是 &lt;% ‘脚本’ 标签，用于流程控制，无输出。 &lt;%_ 删除其前面的空格符 &lt;%= 输出数据到模板（输出是转义 HTML 标签） &lt;%- 输出非转义的数据到模板 &lt;%# 注释标签，不执行、不输出内容 &lt;%% 输出字符串 ‘&lt;%’ %&gt; 一般结束标签 -%&gt; 删除紧随其后的换行符 %&gt; 将结束标签后面的空格符删除 layout.ejs12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;%-include include/header.html %&gt; &lt;p&gt; 这是 layout 的内容 &lt;/p&gt; &lt;%-include include/footer.html %&gt; &lt;% if (condition) { -%&gt; &lt;% for (var i = 0; i &lt; students.length; i++) { -%&gt; &lt;li&gt;&lt;%= students[i]%&gt;&lt;/li&gt; &lt;% } -%&gt; &lt;% } else { -%&gt; &lt;p&gt;condition !== true&lt;/p&gt; &lt;% } -%&gt;&lt;/body&gt;&lt;/html&gt; 此处注意&lt;%- &gt;和&lt;% &gt;的区别，加上’-‘并不会转义，而不加的话可以直接使用&lt;% include include/header.ejs %&gt;ejs书写的模板 header.html12// ./include/header.html &lt;h1&gt;header&lt;/h1&gt; footer.html12// ./include/footer.html&lt;h1&gt;footer&lt;/h1&gt; gulpfile.js123456789101112var gulp = require('gulp');var ejs = require('gulp-ejs');var data = require('gulp-data'); gulp.task('ejs', function() { gulp.src('**.ejs') .pipe(ejs({ students: [&quot;stu1&quot;, &quot;stu2&quot;, &quot;stu3&quot;], condition: false }, {}, { ext: '.html' })) .pipe(gulp.dest('dist'));}); 然后在命令行中使用gulp ejs即gulp+任务名称的格式来执行任务，输出结果。ejs第一个参数为传递的数据，第二个基本不用，第三个是输出html文件 layout.html1234567891011121314// ./dist/layout.html&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;header&lt;/h1&gt; &lt;p&gt; 这是 layout 的内容 &lt;/p&gt; &lt;h1&gt;footer&lt;/h1&gt; &lt;p&gt;condition !== true&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 由此即可完成ejs模板的使用 后记此外，推荐一个github上的项目，gulp-ejs-demo,感觉挺好用的，而且作者是hexo博客主题indigo的作者，风格我挺喜欢的。","link":"/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8Eejs-gulp%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"数字图像处理和PS","text":"学期新开了一门课，数字图像处理，上了几节课之后收获很多，和之前用PS处理图片时候以及前端的CSS很多地方相互印证，原来很多原理不懂，只是看教程上这么做就做了，现在发现有许多地方豁然开朗，于是简单整理一下。 灰度图像和RGB基本概念灰度图像0-255个级别，0是黑色，255是白色 RGB即红色，绿色，蓝色三种颜色，从0-255共256个级别。以红色R为例，如果GB都为255，那么R为0是黑色，R为255则是纯红，其他类似，因此RGB(255,255,255)就可以说是白色，因此如果能看到RGB数值就能判断出来此颜色哪一种成分更多，这也是PS中通道模块的理论支撑。 PS处理 以上是本次处理的素材图，那么启动PS分别用红、绿、蓝三种通道观察图片，通道即把颜色分离，例如下图R通道，越白的地方说明R值越高，也就是越红，越黑的地方说明R值越低，也就越黑，将RGB三个值抽出来可用灰度图像来理解 R通道 G通道 B通道 那么观察图像可以看出，在R通道下白色区域最多，G通道次之，B通道最少，那么可以得出结论，该图像红色居多，绿色次之，蓝色最少几乎没有，那么为什么G通道也有很多白区域呢，原因即火焰中有很多黄色区域，而且红色和绿色值越高，也就越黄。那么有什么用呢。我们知道PS经常需要切图，对于轮廓清晰的图片，我们当然可以手工切图，或者自动选区之类的，但是如果我们要把该火焰图片切出来存成png格式图片呢，手工切不太可能，自动选取效果也不理想，那么我们就可以通过通道图来切图。 切换成R通道图，然后ctrl+左键在R通道下选区 然后拖出来 于是火焰就切出来了，似乎看起来不太亮，那是因为对比的原因，如果背景换成黑色，那么和原图近乎一样，除了一些边缘没有切出来，其他基本一样 将切出来的图片放在黑色背景下的最终效果 感觉火焰更加凝练了，之后就可通过滤镜之类的自由修改了","link":"/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%92%8Cps/"},{"title":"论文查询平台","text":"又是很久都没有整理过了，这次也不立什么一定要坚持写博客的flag了。这一段时间忙了一些别的事情，技术上把Vue全家桶用于项目中实践了一下，也算是收获不少。 大概需求先放一张大概效果图。 需求简单点讲就是学科期刊，以及热点论文什么的查询。内容上分为六个模块，其中一个ESI学科期刊模块，两个顶级论文模块内容基本一样。查询时左侧会分别用关键词、月份、年份、学科进行过滤。然后还要支持导出excel，就是把数据整合成excel表格导出。 需求并不是很复杂，但是实际写的时候确实也是考虑了很多东西，算是在代码规范上更近了一步吧。 结构设计组件抽象学科期刊和顶级论文这三个模块内容基本一致，返回数据不同，因此可以把他们归为一类。 左侧过滤组件1234567&lt;FilterForm v-if=&quot;isRenderTime&quot; filterType=&quot;timeMonth&quot; ref=&quot;checkedMonth&quot; :filterItems=&quot;formData.filterMonth&quot; @give-conditions=&quot;getArticaleData&quot;&gt;&lt;/FilterForm&gt; 左侧抽象出来过滤组件，其中关键词查询都有不用做过多抽象。 分类检索部分分三块，也可以抽象成一个小的过滤组件。通过父级组件传值filterType，来确定渲染成哪一部分的过滤模块 其中由于月份的显示方式不太一样，为了节省空间，一行放了两个。所以需要绑定一个特殊的class，再用一个计算属性isMonth来判断是否是月份过滤，来判断有display: inline-block的class是否显示该组件上 月份、年份、学科这三个过滤条件并不是每个页面都需要，因此根据获取的路由数据来判断哪一个过滤条件需要显示 由于点击一个过滤按钮，需要获取其所有兄弟过滤组件的选中数据，所以这里我通过在过滤组件点击时，向父级元素传递信号，然后在父级元素上通过ref获取了三个过滤组件的值。 vuex数据管理把Vuex的相关代码分割成了数个模块，便于管理。然后提交方式都是通过action异步提交（这样更规范一些？此处后面还需要深入理解一下） 查询里面的条件全部都用了Vuex来管理，关键词、页码、月份、年份、学科（此处可能还需要深入思考一下，关键词、月份、年份、学科这四个确实还有别的兄弟组件渲染的时候需要使用，但仅仅是读取并不会修改，放在Vuex里面管理代码方便了很多，但是究竟有没有更合适的方法还需要深入思考一下。但是页码这个并没有别的组件需要共享，放在里面纯属是因为和后台传参的时候直接读取Vuex的数据就行，图个方便，是否合理确实还要三思一下） 搜索结果，就是后端传回来的文章数据，我也把他放在了Vuex里面管理。当时想的是，获取结果有四种方式，分别是页面跳转、关键词查询、过滤条件、页码这四个部分需要从后端获取数据，后端返回数据以后直接分发提交到Vuex里面，然后页面直接响应式渲染出来（其实也是图个方便，而且也确实目前的水准想不出什么更好的方式来组织结构）。 文章下载全选功能，这个应该是用的比较的合适了。就是点击全选后，所有文章前面的多选框都要确定上，然后若某一个多选框取消了，全选前面的框也要取消。从这个角度看，双方共同维护这个选中的文章数组，两方都是可读可写，此处用的应该可以说是非常合适了。 因此，总结一下，Vuex用了之后非常的方便，但是也可能造成一些Vuex的滥用，目前也确实没有想到比较好的方式来管理，此处需要在项目结束之后深入思考一下。 关于csscss嵌套问题之前为了图方便，往往把子元素都写在其父元素内，导致父元素的class拉的很长，这样一是不便查看，二是不便于组件复用（只有位于特定父元素下，该class才会生效，不便于复用）。重构后，发现代码可读性并不是很高。于是再次重构，将联系紧密的嵌套一起，嵌套层数不超过2层，感觉可读性更强了一些。 还有css不要嵌套选择器，比如说导航 .list a ，像这样可能会导致后面改动的问题，比如说list内又加了一个item，item里加了一个a，这时候就会影响到item a，不便于维护。 将less的全局变量文件抽离12345678910111213141516// 深灰@deep-grey: #e6e6e6;// 浅灰@light-grey: #F1F1F1;// 深色边框@border-deep: #bababa;// 浅色边框@border-light: #d3d3d3;// header底色@header-blue: #2a4c90;// 字体颜色@font-color: #4b505a;// 搜索结果面板背景@content-color: #f8f8f8;// 按钮颜色@button-color: #e4e5ec; 为了方便项目颜色的调整，很多时候取的颜色都是相同的，这里可以使用less的变量定义。但是这里如果每个vue文件都要引入一遍less文件，会很麻烦，也不方便维护。这里使用style-resources-loader插件来管理，npm安装好后，在vue.config.js里面配置 123456789101112const path = require(&quot;path&quot;);module.exports = { pluginOptions: { // 配置less全局变量 &quot;style-resources-loader&quot;: { preProcessor: &quot;less&quot;, patterns: [path.resolve(__dirname, &quot;src/global.less&quot;)] } }}; 配置好后，就可以直接在每个vue中使用了（此处需要研究一下原理）。 axios二次封装1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import axios from &quot;axios&quot;;// import qs from &quot;qs&quot;; // 序列化请求数据，视服务端的要求// import router from &quot;../router&quot;;const Axios = axios.create({ baseURL: &quot;http://106.14.153.164:6374&quot;, timeout: 10000, responseType: &quot;json&quot;, withCredentials: false, // 是否允许带cookie这些 headers: { &quot;Content-Type&quot;: &quot;application/json;charset=utf-8&quot; }});//POST传参序列化(添加请求拦截器)Axios.interceptors.request.use( config =&gt; { // 在发送请求之前做某件事 // if (config.method === &quot;post&quot;) { // // 序列化 // config.data = qs.stringify(config.data); // } // 若是有做鉴权token , 就给头部带上token // 若是需要跨站点,存放到 cookie 会好一点,限制也没那么多,有些浏览环境限制了 localstorage 的使用 // 这里localStorage一般是请求成功后我们自行写入到本地的,因为你放在vuex刷新就没了 // 一些必要的数据写入本地,优先从本地读取 // 这里在api.js里面加了一个参数，控制是否需要传递鉴权 // 当有requiresAuth且为true是加上鉴权 if ( config.requiresAuth &amp;&amp; config.requiresAuth === true &amp;&amp; localStorage.loginUserBaseInfo &amp;&amp; JSON.parse(localStorage.loginUserBaseInfo).jwtCode ) { let token = JSON.parse(localStorage.loginUserBaseInfo).jwtCode; config.headers.Authorization = token; } console.log(&quot;config:&quot;, config); return config; }, error =&gt; { // error 的回调信息 console.log(&quot;request:&quot;, error); return Promise.reject(error); });//返回状态判断(添加响应拦截器)Axios.interceptors.response.use( res =&gt; { //对响应数据做些事 if (res.data &amp;&amp; !(res.data.code === 200)) { console.log(&quot;返回状态判断&quot;); // console.log(&quot;res:&quot;, res); alert(res.data.msg); return Promise.reject(res.data.msg); } console.log(&quot;res:&quot;, res); return res; }, error =&gt; { if (error &amp;&amp; error.response) { let msg = error.response.data.msg; switch (error.response.status) { case 400: alert(&quot;请求错误：&quot; + msg); break; case 401: alert(&quot;未经授权的&quot; + msg); break; case 403: alert(&quot;拒绝访问&quot; + msg); break; case 404: alert(&quot;请求地址出错&quot; + msg); break; case 500: alert(&quot;服务器内部错误&quot;); break; default: alert(&quot;错误&quot;); } } console.log(&quot;response:&quot;, error.response); return Promise.reject(error.response); });export default Axios; 这里由于每次请求分到各个逻辑里面处理的话，代码不好管理，而且代码会很乱，工作量也大。这里把axios做一个二次封装，做一个请求和相应的统一拦截。 比如说很多请求（除了登录）都需要鉴权验证，在请求前做一个请求头统一加上Authorization。然后也可以设置一下统一的Content-Type，这里需要和后端协商一下，让他统一接收参数或者json。如果接收参数的话，也可以使用qs做一个统一序列化。 然后可以共同约定一下返回的错误code，然后把返回的code值根据约定作相应的处理，比如说401鉴权失败，然后重定向到/login 然后也可以把接口统一封装一下，便于修改 然后如果想要在全局使用这个封装好的api，在main.js中引入api文件，然后使用Vue.prototype.$api = api;，(这里应该是把$api放到了Vue的原型上)，就可以在全局通过this.$api调用了 JWT鉴权验证JWT之前一直没用过，这次和后端用了一下，在前后端分离里面用的比较多吧。 那么鉴权验证的流程是什么呢？简单讲就是，前端用户登陆后，后端会返回一个token，然后前端把这个token存到localStorage或者session再或者Vuex里面管理，不同位置有不同的适用范围吧。考虑到session以及Vuex里面管理的话，刷新后就没有了，所以我存到了localStorage里面。 然后每次需要鉴权的时候（比如说这里面的查询就需要鉴权，但是登陆不需要鉴权），把token加到请求头里面，发给后端进行身份验证。然后后端返回code状态码，或者直接重定向什么的都行。 JWT按照我的理解主要用于签名验证，JWT分为三段，验证前两段编码后和第三段是否相同，即可判断是否是目标签名。 具体的一些实现axios拦截1234567if ( localStorage.loginUserBaseInfo &amp;&amp; JSON.parse(localStorage.loginUserBaseInfo).jwtCode) { let token = JSON.parse(localStorage.loginUserBaseInfo).jwtCode; config.headers.Authorization = token;} 这里我一开始把所有的请求都加上了token，这里就是做一个简单的判断，判断本地有没有保存token信息，保存的话就加到请求头里面。 但是后来有一个问题，那就是比如登录并不需要加上token，虽然后端没有判断，一开始并没有什么问题。但是当超过了过期时间之后，我发现登录的时候有莫名的报错，看了好半天才找到了这个问题。那就是后端应该是把这个鉴权统一处理了，那只能我这边来改。 解决方法，在封装过的api请求文件里面，多加上一个参数requiresAuth为true则表示需要鉴权。然后在axios拦截器里面多加上一个判断config.requiresAuth &amp;&amp; config.requiresAuth === true（此处需要深入理解一下Promise和ajax的区别） Promise主要用于异步编程，和ajax并无联系，只不过是因为Promise用于ajax异步后，能解决回调地狱问题，更多实践查看js异步编程 vue-router全局导航守卫这里每次跳转前都要做一个判断，就是判断当前是否有鉴权信息，以及是否过期 12345678910111213141516171819202122232425262728293031323334// vue-router导航守卫，全局守卫// 并不是所有页面请求都需要加上token，所以需要做一个全局守卫// 在路由meta加一个字段requiresAuth,设置为true则必须加上鉴权// 登录页不需要鉴权router.beforeEach((to, from, next) =&gt; { // 如果检测到meta含有字段 if (to.matched.some(res =&gt; res.meta.requiresAuth)) { // 检测是否有鉴权信息 if (localStorage.loginUserBaseInfo) { let lifeTime = JSON.parse(localStorage.loginUserBaseInfo).lifeTime; let nowTime = new Date().getTime(); // 比较当前时间和过期时间 if (nowTime &lt; lifeTime) { // 有鉴权信息而且未过期 next(); } else { // 鉴权已过期，跳转到登录页 alert(&quot;登录状态过期，请重新登录&quot;); next({ path: &quot;/login&quot; }); } } else { // 没有鉴权信息，跳转到登录页 alert(&quot;登录状态过期，请重新登录&quot;); next({ path: &quot;/login&quot; }); } } else { // 无需鉴权信息，继续 next(); }}); 由于后端返回的过期时间是时间段，所以这里判断过期采用的方法是，login登录后获取的过期时间加上getTime()，得到过期时间戳存入localStrage。然后在路由处设置meta字段，来控制路由跳转时是否需要鉴权判断过期时间，如果过期，直接跳转到/login。 二进制流文件下载1234567891011121314151617console.log(response.headers);let content = response.data;let blob = new Blob([content]);let fileName = response.headers[&quot;content-disposition&quot;].split(&quot;=&quot;)[1];if (&quot;download&quot; in document.createElement(&quot;a&quot;)) { // 非IE下载 let elink = document.createElement(&quot;a&quot;); elink.download = fileName; elink.style.display = &quot;none&quot;; elink.href = URL.createObjectURL(blob); document.body.appendChild(elink); elink.click(); URL.revokeObjectURL(elink.href);} else { // IE 10+ 下载 navigator.msSaveBlob(blob, fileName);} 这里后端传我的是二进制流，虽然之前写的项目也是这样处理的，但是一个是当时没有认真研究，而且当时没有使用axios，导致这次也卡了一小段时间。 然后就是Blob对象，Blob 对象表示一个不可变、原始数据的类文件对象。这里创建了一个文本节点，并隐藏，触发点击事件，触发下载。而且需要把api封装的接口设置responseType: &quot;blob&quot;。 这里获取的是excel文件，后端通过Content-Disposition把文件名返回给我，这里其实有一个问题。虽然从network里面分析到了该请求头，但是axios并没有拦截到该请求头，这里需要后端设置Access-Control-Expose-Headers才能获取到该请求头。 但是目前有一个问题还没有解决，那就是后端直接返回我的是data: Blob()，似乎是不能再多返回一个code状态码？没有状态码的话，我前面axios的拦截就不能统一根据返回的code来采取不同的处理。这里暂时没有解决，后面需要尝试写一下后端研究一下。 解决方案：直接判断返回类型，如果返回的是Blob型，直接另一套操作 1if (res.data &amp;&amp; !(res.data instanceof Blob) &amp;&amp; !(res.data.code === 200)) 将共同方法抽离情景：左侧过滤，翻页，页面跳转，排序四处操作都需要发送查询结果的请求，其返回结果都差不多，只是参数数量和数据不同。根据不同模块，其调用接口不相同，而且每处操作有略微不同，这是抽离的难处。但是，每次改动后，都需要将这些方法逐个修改，代码可维护性极差，因此，将其抽离出来势在必行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import store from &quot;@/store/index&quot;;import api from &quot;@/request/api&quot;;/** * 获取ESI期刊的方法抽离 * * 传入两个参数，一个是一级目录名，一个是二级目录名 * 这里两个api接口的传过去的参数不同，但是获取数据后的操作相同 * 所以用if判断了二级目录 * 在全期下是一个接口 * 在当期，当期新增，当期跌出是一个接口 * @param {*} firDirectory * @param {*} secDirectory */export const getEsi = (firDirectory, secDirectory) =&gt; { if (firDirectory === &quot;periodical&quot;) { // 如果当前在esi期刊目录下 if (secDirectory === &quot;all&quot;) { // 如果在全期 // 获取数据 api.search .searchAll() .then(response =&gt; { console.log(response.data.data); // ES6变量解构 let { totalElemNums, data } = response.data.data; let articleTotal = totalElemNums; let articleList = data; // map遍历文章数组，取出esiId属性重新组成数组 let checkedArr = articleList.map(obj =&gt; obj.esiId); // 提交文章数量和文章列表 store.dispatch(&quot;getArticleTotal&quot;, articleTotal); store.dispatch(&quot;getArticleListList&quot;, articleList); // 提交文章id数组 store.dispatch(&quot;getCheckedArr&quot;, checkedArr); // 初始化Vuex中的checkedId store.dispatch(&quot;getCheckedId&quot;, []); }) .catch(error =&gt; { console.log(error); }); } else { // 在esi模块的其它栏目下 const periodicalTimeTxt = { current: &quot;current&quot;, new: &quot;newAddition&quot;, decrease: &quot;fellOut&quot; }; console.log(periodicalTimeTxt[secDirectory]); // 获取数据 api.search .searchCurrent(periodicalTimeTxt[secDirectory]) .then(response =&gt; { // ES6变量解构 let { totalElemNums, data } = response.data.data; let articleTotal = totalElemNums; let articleList = data; // map遍历文章数组，取出esiId属性重新组成数组 let checkedArr = articleList.map(obj =&gt; obj.esiId); // 提交文章数量和文章列表 store.dispatch(&quot;getArticleTotal&quot;, articleTotal); store.dispatch(&quot;getArticleListList&quot;, articleList); // 提交文章id数组 store.dispatch(&quot;getCheckedArr&quot;, checkedArr); // 初始化Vuex中的checkedId store.dispatch(&quot;getCheckedId&quot;, []); }) .catch(error =&gt; { console.log(error); }); } }}; 上面只是列举了期刊的处理办法，由于模块不同，分为两级栏目，因此函数设置了两个参数，一个是一级栏目，一个是二级栏目。根据栏目不同调用不同的处理办法。 其中需要管理vuex，以及调用封装好的api请求接口，因此将这两模块引入，然后在每一处需要使用该方法的地方import导入，根据不同情况调用该方法即可。 Vue插件形式扩展一个全局组件情景：需要做一个类似iview或者element-ui里面的一个全局提示组件，因为alert弹出提示太丑了，该组件多在ajax回调中使用，来显示请求结果成功或者失败 12345678910&lt;template&gt; &lt;transition name=&quot;fade&quot;&gt; &lt;div class=&quot;message&quot; :class=&quot;type&quot; v-show=&quot;show&quot;&gt; &lt;i v-if=&quot;type === 'info'&quot; class=&quot;fa fa-info-circle&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; &lt;i v-else-if=&quot;type === 'success'&quot; class=&quot;fa fa-check-circle&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; &lt;i v-else-if=&quot;type === 'error'&quot; class=&quot;fa fa-times-circle&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; &lt;span class=&quot;text&quot;&gt;{{text}}&lt;/span&gt; &lt;/div&gt; &lt;/transition&gt;&lt;/template&gt; 1234567891011121314151617181920212223let VueMessage = Vue.extend({ render(h) { let props = { type, text: msg, show: this.show }; // return h(&quot;Message&quot;, { props: props }); // ES6简写 return h(&quot;Message&quot;, { props }); }, data() { return { show: false }; }});let newMessage = new VueMessage();let vm = newMessage.$mount();console.log(vm);let el = vm.$el;console.log(el);document.body.appendChild(el); // 把生成的提示的dom插入body中 该组件代码参考了一片文章。只贴了一部分代码。首先，开发插件要使用Vue公开方法install，然后使用了Vue.extend()创建一个子类，后面的Message组件都是以实例化该类形成的，extend()return的参数可以参照Vue官方文档，作者这里使用render()而并未使用template暂时没看明白原因。不过直接使用template也不会有错。 后面就是要先将实例化对象挂载到DOM上，然后通过$el来访问DOM。 123456789101112131415// 添加到window上，暴露三个方法（可以在js文件里直接调用）window.$message = { info(text, callBack) { if (!text) return; msg(&quot;info&quot;, text, callBack); }, success(text, callBack) { if (!text) return; msg(&quot;success&quot;, text, callBack); }, error(text, callBack) { if (!text) return; msg(&quot;error&quot;, text, callBack); }}; 还要提一点，因为我把axios二次封装，所以请求回调都没有写在vue文件里面，而是写在了抽离出来的js文件，因此无法通过Vue组件来调用。因此我将方法也同样添加到了到了window上，暴露了三个方法，然后在js文件中直接使用window.$message.error(msg);来调用。 虽然不知道合不合理，但是确实解决了这一问题。","link":"/%E8%AE%BA%E6%96%87%E6%9F%A5%E8%AF%A2%E5%B9%B3%E5%8F%B0/"},{"title":"hexo源码分析（一）","text":"其实是由一个小问题引发的，在配置icarus主题的时候，发现的一个问题，类似这个链接。就是hexo-renderer-inferno这个插件没有正常运行导致的，但是node_modules中可以很明显的看到，作为hexo-theme-icarus依赖的依赖，是被正常的安装下来了，按照文中的解决方案虽然能解决，但是并没有真正从源头上解决。基于这个原因，想从hexo的源码中看一看插件加载机制。 很明显搜索引擎按照hexo 源码作为关键字的搜索结果中，并没有真正的源码分析，都是非常浅层的解析。所以这里我将从源码的角度尝试分析一下hexo内部的运行机制。 注：hexo的版本&quot;version&quot;: &quot;5.4.0&quot; 导读这里将分几篇文章把我在阅读hexo代码的过程记录一下，作为hexo源码阅读第一篇文章，将分析一下hexo-cli的设计实现思路。 输入 hexo 发生了什么？和其他的脚手架一样，首先是从package.json中的bin字段开始的。bin有什么用可自行去npm文档查看。 hexo的bin我们在安装完npm i hexo之后，可以看到hexo的package.json中的bin字段如下 123&quot;bin&quot;: { &quot;hexo&quot;: &quot;./bin/hexo&quot;}, 此时，执行 hexo命令之后，后续就会被bin/hexo接管，可以看下bin/hexo的内容，直接使用了hexo-cli暴露的方法。 123#!/usr/bin/env node'use strict';require('hexo-cli')(); hexo-cli做的事情接下来我们来看一看hexo-cli做了什么，直接找 package.json中的 main字段，找到入口文件lib/hexo.js，接下来执行hexo ...都会被这里接管。 hexo-cli和其他cli工具类似，里面的实现并不复杂，大致看一下就能了解实现原理，如果想了解一般cli的执行流程，你可以看我之前写的 vue-cli源码学习2.x，里面分析了vue-cli版本2的实现原理。 hexo-cli提供了init、help、version这三个命令，那么此时你一定会有一个疑惑，hexo server、hexo g等等命令是怎么执行的？hexo-cli和hexo两个依赖的关系是怎么样的？ 其实我的最大的疑问也在这里，因为按照cli的惯例，一般所有命令都会在cli中实现对应的逻辑，但是经过调试发现，hexo似乎并不想这么做，而是把其他的命令逻辑放到hexo这个依赖中了。我理解是hexo作为一个暴露出来的核心类，里面的逻辑会很复杂，所以单独抽离出来了，hexo-cli只是提供了很简单的一个功能。那么我们接下来看。 1234567891011121314151617181920212223// hexo-cli/lib/hexo.jsreturn findPkg(cwd, args).then(path =&gt; { if (!path) return; // ...}).then(mod =&gt; { if (mod) hexo = mod; log = hexo.log; // 注册 hexo的控制台命令 require('./console')(hexo); return hexo.init();})function loadModule(path, args) { return Promise.try(() =&gt; { // 会在目标目录中找 hexo这个依赖的路径，然后实例化 hexo const modulePath = resolve.sync('hexo', { basedir: path }); const Hexo = require(modulePath); return new Hexo(path, args); });} 上面这段逻辑就是实例化Hexo的关键步骤，第一遍看的时候没发现，后来才发现这里，这个就是hexo-cli和hexo这两个依赖之间的关系。同时这里也做了保底逻辑，如果没有找到对应的hexo依赖的路径，那么会有一个保底逻辑，直接使用hexo-cli中内置的 Context来实例化 Hexo对象，你可以在hexo-cli/lib/context.js中找到对应的实现。 我们先来看看假如使用hexo-cli中的实例化 Hexo是如何做的 12345678910111213// hexo-cli/lib/context.jsclass Context extends EventEmitter { constructor(base = process.cwd(), args = {}) { super(); this.base_dir = base; this.log = logger(args); this.extend = { console: new ConsoleExtend() }; } // ...} 其他的暂时都不太重要，我们直接省去，我们先来看这一段 1234// hexo-cli/lib/context.jsthis.extend = { console: new ConsoleExtend()}; 这一段赋值了 extend，里面为 console实例化了一个 ConsoleExtend对象，为什么要看这个？ 123// hexo-cli/lib/hexo.js// 注册 hexo的控制台命令require('./console')(hexo); 上面这段逻辑注册了 hexo的命令，那么里面是如何实现的插件注册逻辑？ hexo-cli的插件式结构1234567891011121314151617181920// hexo-cli/lib/console/index.jsmodule.exports = function(ctx) { const { console } = ctx.extend; console.register('help', 'Get help on a command.', {}, require('./help')); console.register('init', 'Create a new Hexo folder.', { desc: 'Create a new Hexo folder at the specified path or the current directory.', usage: '[destination]', arguments: [ {name: 'destination', desc: 'Folder path. Initialize in current folder if not specified'} ], options: [ {name: '--no-clone', desc: 'Copy files instead of cloning from GitHub'}, {name: '--no-install', desc: 'Skip npm install'} ] }, require('./init')); console.register('version', 'Display version information.', {}, require('./version'));}; 使用了 Hexo实例化的 extend字段，里面的 console就是 ConsoleExtend实例化的对象，使用 console.register来为hexo控制台提供命令注册，我们来看下ConsoleExtend的具体实现。 123456789101112131415// hexo-cli/lib/extend/console.jsclass Console { constructor() { this.store = {}; this.alias = {}; } register(name, desc, options, fn) { // ... this.store[name.toLowerCase()] = fn; const c = fn; c.options = options; c.desc = desc; }} 可以看到这里最核心的部分其实就是为传进来的回调方法添加上 options和 desc属性，因为fn传递的是引用，因此这里是会为传进来的fn修改对应的 options和 desc的。hexo的命令存储结构是类似 { [name]: fn: Function }这种结构的（虽然我个人觉得这种方式不太好，更理想的结构应该是{ [name]: { fn: Function, desc: string } }，类似这样的结构）。不过这不重要，知道整体的设计思路即可。 所有调用register的都会被记录到 Hexo实例对象的 store字段中，这样就完成了插件的注册步骤，最终结构类似下面 12345678910111213141516{ help: [Function (anonymous)] { options: {}, desc: 'Get help on a command.' }, init: [Function (anonymous)] { options: { desc: 'Create a new Hexo folder at the specified path or the current directory.', usage: '[destination]', arguments: [Array], options: [Array] }, desc: 'Create a new Hexo folder.' }, version: [Function (anonymous)] { options: {}, desc: 'Display version information.' }} 如何执行 hexo ？123456789101112131415161718192021222324function entry(cwd = process.cwd(), args) { // ... return findPkg(cwd, args).then(path =&gt; { // ... }).then(mod =&gt; { // ... }).then(() =&gt; { let cmd = 'help'; if (!args.h &amp;&amp; !args.help) { const c = args._.shift(); // 这里取到 hexo命令执行的 目标 // 比如 cmd = 'init' if (c &amp;&amp; hexo.extend.console.get(c)) cmd = c; } watchSignal(hexo); // 执行的关键 hexo.call()，cmd代表从命令行中取到的命令 return hexo.call(cmd, args).then(() =&gt; hexo.exit()).catch(err =&gt; hexo.exit(err).then(() =&gt; { // `hexo.exit()` already dumped `err` handleError(null); })); }).catch(handleError);} 我们依然只看关键的代码逻辑，可以看到hexo.call(cmd, args)这句代码就是执行的关键，里面的cmd参数代表了想要执行的命令，然后我们来看看hexo.call()的实现。 1234567891011121314151617181920class Context extends EventEmitter { // ... call(name, args, callback) { if (!callback &amp;&amp; typeof args === 'function') { callback = args; args = {}; } return new Promise((resolve, reject) =&gt; { const c = this.extend.console.get(name); // c是 fn，fn有 options和 desc if (c) { c.call(this, args).then(resolve, reject); } else { reject(new Error(`Console \\`${name}\\` has not been registered yet!`)); } }).asCallback(callback); } // ...} 就是直接调用我们上文中register注册的方法，然后根据传入的name执行对应的方法回调。hexo-cli提供了init、help、version三个命令（不包含hexo依赖中注册的），你可以去hexo-cli/lib/console中去查看对应的三个命令实现，这里不再赘述，我们只提供主干流程的梳理，对应的细节你可以去代码中查看。 hexo-cli的执行过程至此，hexo-cli的整体实现逻辑，我们已经看完了。画一张流程图简单梳理一下。 小结整个cli的过程其实大同小异，和其他的cli整体实现思路比较类似。","link":"/hexo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"hexo源码分析（二）","text":"我们上篇文章分析了hexo-cli的执行原理，那么本篇文章，将分析一下hexo这个依赖中做的事情。将尝试分析一下hexo的内部处理机制。 Hexo类我们承接上文hexo源码分析（一）中的逻辑介绍，里面对Hexo进行了实例化，并执行了hexo.init()。因此我们就从这里开始进行分析。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485class Hexo extends EventEmitter { constructor(base = process.cwd(), args = {}) { super(); // 这里定义了一些关键的路径，比如项目的路径，theme路径，plugin路径等等 // 因为 Hexo实例贯穿整个执行逻辑，因此这里定义的一些路径信息方便后面使用 this.base_dir = base + sep; this.public_dir = join(base, 'public') + sep; this.source_dir = join(base, 'source') + sep; // hexo插件一般命名规范都是 hexo-...结构，后面在读取插件的时候会正则判断 this.plugin_dir = join(base, 'node_modules') + sep; this.script_dir = join(base, 'scripts') + sep; this.scaffold_dir = join(base, 'scaffolds') + sep; // 这里的 theme路径有两种可能 // 1. [project-name]/theme (优先级高) // 2. [project-name]/node_modules/hexo-theme-[name] this.theme_dir = join(base, 'themes', defaultConfig.theme) + sep; this.theme_script_dir = join(this.theme_dir, 'scripts') + sep; // ... // 这里定义了一些比较关键的 extend方法，里面全部都是通过 register来注册进来的 // 这里的对应逻辑可在 hexo/lib/extend中查看，都是暴露出来的注册类 this.extend = { // hexo-cli命令行注册的一些命令，在hexo/lib/plugins/console/index.js中注册进来 console: new Console(), deployer: new Deployer(), // filter可以理解为拦截器，在 hexo执行过程中，会看到很多 execFilter(type, data, options)这种的逻辑，就是在某些环节调用对应的拦截器逻辑 // 可在 hexo/lib/plugins/filter找对应的拦截逻辑 filter: new Filter(), generator: new Generator(), helper: new Helper(), injector: new Injector(), migrator: new Migrator(), processor: new Processor(), // 也是一个比较关键的逻辑，提供给文件渲染，比如 markdown -&gt; html, yml -&gt; json 等等，模板渲染逻辑都通过这里注册 renderer: new Renderer(), tag: new Tag() }; // ... // 这里 hexo存储数据的方式是在 [project-name]/db.json 中，里面记录了整个静态网站的数据信息，比如文章内容，资源文件路径等等 // hexo会有在更新的时候会去判断文件的 hash来判断文件是否修改，只针对修改过的文件进行渲染生成 this.database = new Database({ version: dbVersion, path: join(dbPath, 'db.json') }); // 引入 models里所有的关键操作，比如 Cache registerModels(this); // 这里定义了一些 db.json的查询方式 this._bindLocals(); } // ... init() { // debug模式下会打印出来，在执行命令的时候后面跟上 --debug即可进入该模式，方便查看整个执行流程，便于定位问题 // 具体实现可查看 hexo-log this.log.debug('Hexo version: %s', magenta(this.version)); this.log.debug('Working directory: %s', magenta(tildify(this.base_dir))); // Load internal plugins // hexo/lib/plugins中，基本都是使用 hexo/lib/extend 中实例的对象来进行注册 require('../plugins/console')(this); require('../plugins/filter')(this); require('../plugins/generator')(this); require('../plugins/helper')(this); require('../plugins/injector')(this); require('../plugins/processor')(this); require('../plugins/renderer')(this); require('../plugins/tag')(this); // Load config return Promise.each([ 'update_package', // Update package.json 'load_config', // Load config 'load_theme_config', // Load alternate theme config // 比如一些 模板渲染插件就是在这里被加载进来的，例 hexo-renderer-ejs 'load_plugins' // Load external plugins &amp; scripts ], name =&gt; require(`./${name}`)(this)).then(() =&gt; this.execFilter('after_init', null, {context: this})).then(() =&gt; { // Ready to go! this.emit('ready'); }); }} 先来看这一段代码，里面的部分逻辑添加上了一些我的理解注释，这一部分就是Hexo内部的启动逻辑。","link":"/hexo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/"}],"tags":[{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"项目","slug":"项目","link":"/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"Express","slug":"Express","link":"/tags/Express/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"jQuery","slug":"jQuery","link":"/tags/jQuery/"},{"name":"npm","slug":"npm","link":"/tags/npm/"},{"name":"gulp","slug":"gulp","link":"/tags/gulp/"},{"name":"总结","slug":"总结","link":"/tags/%E6%80%BB%E7%BB%93/"},{"name":"P5JS","slug":"P5JS","link":"/tags/P5JS/"},{"name":"图形学","slug":"图形学","link":"/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"Promise","slug":"Promise","link":"/tags/Promise/"},{"name":"优化","slug":"优化","link":"/tags/%E4%BC%98%E5%8C%96/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"性能","slug":"性能","link":"/tags/%E6%80%A7%E8%83%BD/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"cli","slug":"cli","link":"/tags/cli/"},{"name":"浏览器","slug":"浏览器","link":"/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"ejs","slug":"ejs","link":"/tags/ejs/"},{"name":"PS","slug":"PS","link":"/tags/PS/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"源码","slug":"源码","link":"/tags/%E6%BA%90%E7%A0%81/"}],"categories":[{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"hexo","slug":"hexo","link":"/categories/hexo/"},{"name":"项目","slug":"项目","link":"/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"PS","slug":"PS","link":"/categories/PS/"},{"name":"总结","slug":"总结","link":"/categories/%E6%80%BB%E7%BB%93/"},{"name":"图形学","slug":"图形学","link":"/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]}